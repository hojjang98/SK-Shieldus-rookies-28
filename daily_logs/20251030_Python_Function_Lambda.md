# 📄 2025.10.30 (Day 4) [함수, 람다, 클로저, 스코프]

## 1. 🧠 핵심 개념 정리 (Concepts)

* 핵심1 — **함수 (Function)**: 코드의 **재사용성** 및 **유지보수 용이성**을 확보하여, 탐지 로직이나 데이터 전처리 과정의 **모듈화**에 필수적.
* 핵심2 — **람다 함수 (Lambda)**: `map`, `filter`, `sorted` 등 **내장 함수와 결합**하여 로그 데이터의 간결한 **조건 필터링 및 변환** 로직 구현에 사용.
* 핵심3 — **스코프 (LEGB 규칙)**: 변수 접근 범위를 명확히 하여 **전역 변수의 오용(Misuse)**을 방지하고, **데이터의 안전한 관리**를 보장.
* 핵심4 — **클로저 (Closure)**: 외부 함수의 변수를 기억하여, **전역 변수 없이** 함수 내부에서 **카운터나 상태를 안전하게 유지**하는 로직 구현에 활용.
* 핵심5 — **데코레이터 (Decorator)**: 함수 전후에 **권한 체크, 로깅, 실행시간 측정** 등의 **공통 보안 로직**을 간결하게 추가(장식)하는 고급 기법.

---

## 2. 💻 실습 코드 & 응용 (Practice & Code)

```python
# 보안 함수 작성 (입력값 검증 및 인코딩)
from urllib.parse import quote

def safe_makeUrl(lst: list) -> list:
    # 1. 입력 타입 검증 (Type Check)
    if not isinstance(lst, list): raise TypeError("입력 타입 오류")
    # 2. XSS 방지를 위한 URL 인코딩 적용
    return list(map(lambda x: 'www.'+quote(x)+'.com', lst))
```
- 사용 맥락: API 요청 생성 또는 URL 리스트 처리 시, 입력값에 스크립트와 같은 악성 문자열이 포함되는 것을 URL 인코딩하여 XSS(크로스 사이트 스크립팅) 취약점을 방지.
- 확장 아이디어: quote() 대신, html.escape()를 사용하여 웹 페이지 출력 시의 안전성까지 고려한 필터링 함수를 구성.

# 클로저를 이용한 안전한 상태 유지 (로그 카운터)

```python
def log_counter():
    count = 0 # 전역 변수를 쓰지 않고 '인클로징 변수'로 상태 유지
    def increase():
        nonlocal count
        count += 1
        return count
    return increase 

cnt = log_counter()
# print(cnt())
```

- 사용 맥락: 특정 이벤트(예: 로그인 실패, 접근 차단) 발생 횟수를 전역 변수 노출 없이 안전하게 카운트하여 임계치 기반 탐지 로직의 기반으로 활용.
- 확장 아이디어: 일정 임계치(예: 5회) 도달 시 count를 초기화하고 Alert을 발생시키는 조건 로직 추가.

```python
# 가변 인자를 이용한 API 요청 쿼리 생성
from urllib.parse import urlencode

def makeApiRequest(endpoint, **params):
    # 화이트리스트 검증을 통해 불필요/악성 파라미터 제외 (보안 개선점)
    white_lst = {'q', 'page', 'lang'}
    safeParams = { k: v for k, v in params.items() if k in white_lst} 
    queryString = urlencode(safeParams)
    return endpoint +'?'+queryString
```

- 사용 맥락: API 통신 시 요청 파라미터(쿼리 스트링)를 동적으로 생성. 특히 **white_lst**를 사용해 허용된 파라미터만 사용하도록 강제하여 불필요한 정보 노출이나 잘못된 인자 주입을 방지.
- 확장 아이디어: urlencode 시 URL 인코딩을 자동으로 수행하므로, 파라미터 값에 악성 스크립트가 포함되어도 안전하게 처리됨.

## 3. 🛡️ 보안 관점 분석 (Security Insight)

* **관점1 — 입력 검증 및 안전한 출력 (함수 활용)**:
    * **적용방식**: 모든 **외부 입력 데이터**가 처리되는 지점에 **함수**를 정의하고, 그 함수 내에서 **타입 검사 (`isinstance`)**, **악성 문자열 필터링**, **URL 인코딩 (`quote`)** 등을 강제하여 XSS나 주입 공격을 방지하는 **보안 게이트웨이** 역할 수행.

* **관점2 — 상태 관리의 안정성 (클로저 vs 전역 변수)**:
    * **적용방식**: **전역 변수**는 어떤 함수에서든 접근 및 수정이 가능해 **보안상 취약**할 수 있다.  **클로저**를 활용하면 **특정 기능(예: 실패 로그인 카운터)**에만 접근 가능한 **폐쇄적인 상태(`count` 변수)**를 유지하여, 전역 변수 오염 없이 안전하게 임계치 기반 탐지 로직을 구현할 수 있다.

* **관점3 — 공통 보안 로직의 적용 (데코레이터)**:
    * **적용방식**: 인증/인가가 필요한 API 함수나 민감 정보 처리 함수에 **데코레이터**를 적용하여 **권한 체크** 또는 **데이터 마스킹 로깅**과 같은 **공통 보안 기능**을 함수 로직 변경 없이 일괄적으로 적용하여 보안 통제 일관성을 확보.

* **관점4 — API 파라미터 제어 (가변 인자 및 화이트리스트)**:
    * **적용방식**: `**kwargs` 가변 인자를 사용할 때, **허용된 파라미터 키(Whitelist)**만 필터링하여 API 요청을 구성해야 **불필요한 서버 리소스 소모**나 **숨겨진 설정값 변경 시도** 등의 공격 시도를 방지할 수 있다.

---

## 4. 🧩 요약 (Summary)

1.  함수는 **모듈화**를 통해 탐지 로직을 재사용 가능하게 만들고, 함수 내에서 **입력 검증 및 안전한 인코딩**을 수행하여 **취약점을 사전 방어**하는 핵심 구조이다.
2.  **클로저**는 **전역 변수의 위험 없이** **임계치 카운터**와 같은 **상태를 안전하게 유지**할 수 있는 실무적인 대안이며, **데코레이터**는 공통의 **권한 체크/로깅** 로직을 쉽게 추가할 수 있게 한다.
3.  **람다**와 `map`, `filter`는 로그 데이터의 **빠른 변환 및 필터링**에 유용하며, `**kwargs`를 사용할 때는 **화이트리스트 검증**을 통해 불필요한 API 파라미터 주입을 반드시 통제해야 한다.